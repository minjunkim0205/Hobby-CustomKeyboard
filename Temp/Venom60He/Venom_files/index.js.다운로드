/*

┏━━━┓╋╋╋╋╋╋╋╋╋╋╋╋╋┏┓╋╋╋╋╋╋┏━━━┳┓╋╋╋╋╋╋╋╋╋┏┓┏━┳━━┓
┃┏━┓┃╋╋╋╋╋╋╋╋╋╋╋╋╋┃┃╋╋╋╋╋╋┃┏━┓┃┃╋╋╋╋╋╋╋╋╋┃┃┃┏┫┏┓┃
┃┗━┛┣━━┳┓┏┓┏┳━━┳━┓┃┗━┳┓╋┏┓┃┗━━┫┗━┳━━┳━┳━━┫┗┛┛┃┗┛┗┓
┃┏━━┫┏┓┃┗┛┗┛┃┃━┫┏┛┃┏┓┃┃╋┃┃┗━━┓┃┏┓┃┏┓┃┏┫┏┓┃┏┓┃┃┏━┓┃
┃┃╋╋┃┗┛┣┓┏┓┏┫┃━┫┃╋┃┗┛┃┗━┛┃┃┗━┛┃┃┃┃┏┓┃┃┃┗┛┃┃┃┗┫┗━┛┃
┗┛╋╋┗━━┛┗┛┗┛┗━━┻┛╋┗━━┻━┓┏┛┗━━━┻┛┗┻┛┗┻┛┃┏━┻┛┗━┻━━━┛
╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋┏━┛┃╋╋╋╋╋╋╋╋╋╋╋╋╋┃┃
╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋┗━━┛╋╋╋╋╋╋╋╋╋╋╋╋╋┗┛

┏━━━┓╋╋╋╋╋╋╋╋╋╋╋╋╋┏┓╋╋╋╋╋╋┏━━━┳┓╋╋╋╋╋╋╋╋╋┏┓┏━┳━━┓
┃┏━┓┃╋╋╋╋╋╋╋╋╋╋╋╋╋┃┃╋╋╋╋╋╋┃┏━┓┃┃╋╋╋╋╋╋╋╋╋┃┃┃┏┫┏┓┃
┃┗━┛┣━━┳┓┏┓┏┳━━┳━┓┃┗━┳┓╋┏┓┃┗━━┫┗━┳━━┳━┳━━┫┗┛┛┃┗┛┗┓
┃┏━━┫┏┓┃┗┛┗┛┃┃━┫┏┛┃┏┓┃┃╋┃┃┗━━┓┃┏┓┃┏┓┃┏┫┏┓┃┏┓┃┃┏━┓┃
┃┃╋╋┃┗┛┣┓┏┓┏┫┃━┫┃╋┃┗┛┃┗━┛┃┃┗━┛┃┃┃┃┏┓┃┃┃┗┛┃┃┃┗┫┗━┛┃
┗┛╋╋┗━━┛┗┛┗┛┗━━┻┛╋┗━━┻━┓┏┛┗━━━┻┛┗┻┛┗┻┛┃┏━┻┛┗━┻━━━┛
╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋┏━┛┃╋╋╋╋╋╋╋╋╋╋╋╋╋┃┃
╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋┗━━┛╋╋╋╋╋╋╋╋╋╋╋╋╋┗┛

┏━━━┓╋╋╋╋╋╋╋╋╋╋╋╋╋┏┓╋╋╋╋╋╋┏━━━┳┓╋╋╋╋╋╋╋╋╋┏┓┏━┳━━┓
┃┏━┓┃╋╋╋╋╋╋╋╋╋╋╋╋╋┃┃╋╋╋╋╋╋┃┏━┓┃┃╋╋╋╋╋╋╋╋╋┃┃┃┏┫┏┓┃
┃┗━┛┣━━┳┓┏┓┏┳━━┳━┓┃┗━┳┓╋┏┓┃┗━━┫┗━┳━━┳━┳━━┫┗┛┛┃┗┛┗┓
┃┏━━┫┏┓┃┗┛┗┛┃┃━┫┏┛┃┏┓┃┃╋┃┃┗━━┓┃┏┓┃┏┓┃┏┫┏┓┃┏┓┃┃┏━┓┃
┃┃╋╋┃┗┛┣┓┏┓┏┫┃━┫┃╋┃┗┛┃┗━┛┃┃┗━┛┃┃┃┃┏┓┃┃┃┗┛┃┃┃┗┫┗━┛┃
┗┛╋╋┗━━┛┗┛┗┛┗━━┻┛╋┗━━┻━┓┏┛┗━━━┻┛┗┻┛┗┻┛┃┏━┻┛┗━┻━━━┛
╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋┏━┛┃╋╋╋╋╋╋╋╋╋╋╋╋╋┃┃
╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋┗━━┛╋╋╋╋╋╋╋╋╋╋╋╋╋┗┛

┏━━━┓╋╋╋╋╋╋╋╋╋╋╋╋╋┏┓╋╋╋╋╋╋┏━━━┳┓╋╋╋╋╋╋╋╋╋┏┓┏━┳━━┓
┃┏━┓┃╋╋╋╋╋╋╋╋╋╋╋╋╋┃┃╋╋╋╋╋╋┃┏━┓┃┃╋╋╋╋╋╋╋╋╋┃┃┃┏┫┏┓┃
┃┗━┛┣━━┳┓┏┓┏┳━━┳━┓┃┗━┳┓╋┏┓┃┗━━┫┗━┳━━┳━┳━━┫┗┛┛┃┗┛┗┓
┃┏━━┫┏┓┃┗┛┗┛┃┃━┫┏┛┃┏┓┃┃╋┃┃┗━━┓┃┏┓┃┏┓┃┏┫┏┓┃┏┓┃┃┏━┓┃
┃┃╋╋┃┗┛┣┓┏┓┏┫┃━┫┃╋┃┗┛┃┗━┛┃┃┗━┛┃┃┃┃┏┓┃┃┃┗┛┃┃┃┗┫┗━┛┃
┗┛╋╋┗━━┛┗┛┗┛┗━━┻┛╋┗━━┻━┓┏┛┗━━━┻┛┗┻┛┗┻┛┃┏━┻┛┗━┻━━━┛
╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋┏━┛┃╋╋╋╋╋╋╋╋╋╋╋╋╋┃┃
╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋┗━━┛╋╋╋╋╋╋╋╋╋╋╋╋╋┗┛

┏━━━┓╋╋╋╋╋╋╋╋╋╋╋╋╋┏┓╋╋╋╋╋╋┏━━━┳┓╋╋╋╋╋╋╋╋╋┏┓┏━┳━━┓
┃┏━┓┃╋╋╋╋╋╋╋╋╋╋╋╋╋┃┃╋╋╋╋╋╋┃┏━┓┃┃╋╋╋╋╋╋╋╋╋┃┃┃┏┫┏┓┃
┃┗━┛┣━━┳┓┏┓┏┳━━┳━┓┃┗━┳┓╋┏┓┃┗━━┫┗━┳━━┳━┳━━┫┗┛┛┃┗┛┗┓
┃┏━━┫┏┓┃┗┛┗┛┃┃━┫┏┛┃┏┓┃┃╋┃┃┗━━┓┃┏┓┃┏┓┃┏┫┏┓┃┏┓┃┃┏━┓┃
┃┃╋╋┃┗┛┣┓┏┓┏┫┃━┫┃╋┃┗┛┃┗━┛┃┃┗━┛┃┃┃┃┏┓┃┃┃┗┛┃┃┃┗┫┗━┛┃
┗┛╋╋┗━━┛┗┛┗┛┗━━┻┛╋┗━━┻━┓┏┛┗━━━┻┛┗┻┛┗┻┛┃┏━┻┛┗━┻━━━┛
╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋┏━┛┃╋╋╋╋╋╋╋╋╋╋╋╋╋┃┃
╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋┗━━┛╋╋╋╋╋╋╋╋╋╋╋╋╋┗┛

┏━━━┓╋╋╋╋╋╋╋╋╋╋╋╋╋┏┓╋╋╋╋╋╋┏━━━┳┓╋╋╋╋╋╋╋╋╋┏┓┏━┳━━┓
┃┏━┓┃╋╋╋╋╋╋╋╋╋╋╋╋╋┃┃╋╋╋╋╋╋┃┏━┓┃┃╋╋╋╋╋╋╋╋╋┃┃┃┏┫┏┓┃
┃┗━┛┣━━┳┓┏┓┏┳━━┳━┓┃┗━┳┓╋┏┓┃┗━━┫┗━┳━━┳━┳━━┫┗┛┛┃┗┛┗┓
┃┏━━┫┏┓┃┗┛┗┛┃┃━┫┏┛┃┏┓┃┃╋┃┃┗━━┓┃┏┓┃┏┓┃┏┫┏┓┃┏┓┃┃┏━┓┃
┃┃╋╋┃┗┛┣┓┏┓┏┫┃━┫┃╋┃┗┛┃┗━┛┃┃┗━┛┃┃┃┃┏┓┃┃┃┗┛┃┃┃┗┫┗━┛┃
┗┛╋╋┗━━┛┗┛┗┛┗━━┻┛╋┗━━┻━┓┏┛┗━━━┻┛┗┻┛┗┻┛┃┏━┻┛┗━┻━━━┛
╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋┏━┛┃╋╋╋╋╋╋╋╋╋╋╋╋╋┃┃
╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋┗━━┛╋╋╋╋╋╋╋╋╋╋╋╋╋┗┛

┏━━━┓╋╋╋╋╋╋╋╋╋╋╋╋╋┏┓╋╋╋╋╋╋┏━━━┳┓╋╋╋╋╋╋╋╋╋┏┓┏━┳━━┓
┃┏━┓┃╋╋╋╋╋╋╋╋╋╋╋╋╋┃┃╋╋╋╋╋╋┃┏━┓┃┃╋╋╋╋╋╋╋╋╋┃┃┃┏┫┏┓┃
┃┗━┛┣━━┳┓┏┓┏┳━━┳━┓┃┗━┳┓╋┏┓┃┗━━┫┗━┳━━┳━┳━━┫┗┛┛┃┗┛┗┓
┃┏━━┫┏┓┃┗┛┗┛┃┃━┫┏┛┃┏┓┃┃╋┃┃┗━━┓┃┏┓┃┏┓┃┏┫┏┓┃┏┓┃┃┏━┓┃
┃┃╋╋┃┗┛┣┓┏┓┏┫┃━┫┃╋┃┗┛┃┗━┛┃┃┗━┛┃┃┃┃┏┓┃┃┃┗┛┃┃┃┗┫┗━┛┃
┗┛╋╋┗━━┛┗┛┗┛┗━━┻┛╋┗━━┻━┓┏┛┗━━━┻┛┗┻┛┗┻┛┃┏━┻┛┗━┻━━━┛
╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋┏━┛┃╋╋╋╋╋╋╋╋╋╋╋╋╋┃┃
╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋┗━━┛╋╋╋╋╋╋╋╋╋╋╋╋╋┗┛

┏━━━┓╋╋╋╋╋╋╋╋╋╋╋╋╋┏┓╋╋╋╋╋╋┏━━━┳┓╋╋╋╋╋╋╋╋╋┏┓┏━┳━━┓
┃┏━┓┃╋╋╋╋╋╋╋╋╋╋╋╋╋┃┃╋╋╋╋╋╋┃┏━┓┃┃╋╋╋╋╋╋╋╋╋┃┃┃┏┫┏┓┃
┃┗━┛┣━━┳┓┏┓┏┳━━┳━┓┃┗━┳┓╋┏┓┃┗━━┫┗━┳━━┳━┳━━┫┗┛┛┃┗┛┗┓
┃┏━━┫┏┓┃┗┛┗┛┃┃━┫┏┛┃┏┓┃┃╋┃┃┗━━┓┃┏┓┃┏┓┃┏┫┏┓┃┏┓┃┃┏━┓┃
┃┃╋╋┃┗┛┣┓┏┓┏┫┃━┫┃╋┃┗┛┃┗━┛┃┃┗━┛┃┃┃┃┏┓┃┃┃┗┛┃┃┃┗┫┗━┛┃
┗┛╋╋┗━━┛┗┛┗┛┗━━┻┛╋┗━━┻━┓┏┛┗━━━┻┛┗┻┛┗┻┛┃┏━┻┛┗━┻━━━┛
╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋┏━┛┃╋╋╋╋╋╋╋╋╋╋╋╋╋┃┃
╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋┗━━┛╋╋╋╋╋╋╋╋╋╋╋╋╋┗┛

┏━━━┓╋╋╋╋╋╋╋╋╋╋╋╋╋┏┓╋╋╋╋╋╋┏━━━┳┓╋╋╋╋╋╋╋╋╋┏┓┏━┳━━┓
┃┏━┓┃╋╋╋╋╋╋╋╋╋╋╋╋╋┃┃╋╋╋╋╋╋┃┏━┓┃┃╋╋╋╋╋╋╋╋╋┃┃┃┏┫┏┓┃
┃┗━┛┣━━┳┓┏┓┏┳━━┳━┓┃┗━┳┓╋┏┓┃┗━━┫┗━┳━━┳━┳━━┫┗┛┛┃┗┛┗┓
┃┏━━┫┏┓┃┗┛┗┛┃┃━┫┏┛┃┏┓┃┃╋┃┃┗━━┓┃┏┓┃┏┓┃┏┫┏┓┃┏┓┃┃┏━┓┃
┃┃╋╋┃┗┛┣┓┏┓┏┫┃━┫┃╋┃┗┛┃┗━┛┃┃┗━┛┃┃┃┃┏┓┃┃┃┗┛┃┃┃┗┫┗━┛┃
┗┛╋╋┗━━┛┗┛┗┛┗━━┻┛╋┗━━┻━┓┏┛┗━━━┻┛┗┻┛┗┻┛┃┏━┻┛┗━┻━━━┛
╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋┏━┛┃╋╋╋╋╋╋╋╋╋╋╋╋╋┃┃
╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋┗━━┛╋╋╋╋╋╋╋╋╋╋╋╋╋┗┛

┏━━━┓╋╋╋╋╋╋╋╋╋╋╋╋╋┏┓╋╋╋╋╋╋┏━━━┳┓╋╋╋╋╋╋╋╋╋┏┓┏━┳━━┓
┃┏━┓┃╋╋╋╋╋╋╋╋╋╋╋╋╋┃┃╋╋╋╋╋╋┃┏━┓┃┃╋╋╋╋╋╋╋╋╋┃┃┃┏┫┏┓┃
┃┗━┛┣━━┳┓┏┓┏┳━━┳━┓┃┗━┳┓╋┏┓┃┗━━┫┗━┳━━┳━┳━━┫┗┛┛┃┗┛┗┓
┃┏━━┫┏┓┃┗┛┗┛┃┃━┫┏┛┃┏┓┃┃╋┃┃┗━━┓┃┏┓┃┏┓┃┏┫┏┓┃┏┓┃┃┏━┓┃
┃┃╋╋┃┗┛┣┓┏┓┏┫┃━┫┃╋┃┗┛┃┗━┛┃┃┗━┛┃┃┃┃┏┓┃┃┃┗┛┃┃┃┗┫┗━┛┃
┗┛╋╋┗━━┛┗┛┗┛┗━━┻┛╋┗━━┻━┓┏┛┗━━━┻┛┗┻┛┗┻┛┃┏━┻┛┗━┻━━━┛
╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋┏━┛┃╋╋╋╋╋╋╋╋╋╋╋╋╋┃┃
╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋╋┗━━┛╋╋╋╋╋╋╋╋╋╋╋╋╋┗┛
*/



async function fetchfirmware_new(productId, version) {
    let prodId = productId.toString();
    const resp = await window.fetch(window.location.href + 'skb/firmware/' + prodId + '/firmware.json', {
        method: 'GET',
    });
    if (resp.ok) {
        const rj = await resp.blob();
        const fw_list = JSON.parse(await rj.text());
        for (const list of fw_list.firmware) {
            if (version == list.firmware_version) {
                console.log(version);
                console.log(window.location.href +
                    'skb/firmware/' + prodId + '/' +
                    list.firmware_locate);
                let fw_file = await window.fetch(window.location.href +
                    'skb/firmware/' + prodId + '/' +
                    list.firmware_locate, {
                    method: 'GET',
                });
                const r = new FileReader();
                if (fw_file.ok) {
                    const firmwareblob = await fw_file.blob();
                    r.readAsArrayBuffer(firmwareblob);
                    console.log(r);
                    return r;
                }
            }
        }
        return null;
    }
    else {
        return null;
    }
}
function pad(n) {
    let string = "" + n;
    let pad = "0000";
    let r = pad.substring(0, pad.length - string.length) + string;
    return r;
}
var MD5 = function (d) {
    const r = M(V(Y(X(d), 8 * d.length)));
    return r.toLowerCase();
};
function M(d) {
    for (var _, m = '0123456789ABCDEF', f = '', r = 0; r < d.length; r++)
        (_ = d.charCodeAt(r)), (f += m.charAt((_ >>> 4) & 15) + m.charAt(15 & _));
    return f;
}
function X(d) {
    for (var _ = Array(d.length >> 2), m = 0; m < _.length; m++)
        _[m] = 0;
    for (m = 0; m < 8 * d.length; m += 8)
        _[m >> 5] |= (255 & d.charCodeAt(m / 8)) << m % 32;
    return _;
}
function V(d) {
    for (var _ = '', m = 0; m < 32 * d.length; m += 8)
        _ += String.fromCharCode((d[m >> 5] >>> m % 32) & 255);
    return _;
}
function Y(d, _) {
    (d[_ >> 5] |= 128 << _ % 32), (d[14 + (((_ + 64) >>> 9) << 4)] = _);
    for (var m = 1732584193, f = -271733879, r = -1732584194, i = 271733878, n = 0; n < d.length; n += 16) {
        const h = m, t = f, g = r, e = i;
        (f = md5_ii((f = md5_ii((f = md5_ii((f = md5_ii((f = md5_hh((f = md5_hh((f = md5_hh((f = md5_hh((f = md5_gg((f = md5_gg((f = md5_gg((f = md5_gg((f = md5_ff((f = md5_ff((f = md5_ff((f = md5_ff(f, (r = md5_ff(r, (i = md5_ff(i, (m = md5_ff(m, f, r, i, d[n + 0], 7, -680876936)), f, r, d[n + 1], 12, -389564586)), m, f, d[n + 2], 17, 606105819)), i, m, d[n + 3], 22, -1044525330)), (r = md5_ff(r, (i = md5_ff(i, (m = md5_ff(m, f, r, i, d[n + 4], 7, -176418897)), f, r, d[n + 5], 12, 1200080426)), m, f, d[n + 6], 17, -1473231341)), i, m, d[n + 7], 22, -45705983)), (r = md5_ff(r, (i = md5_ff(i, (m = md5_ff(m, f, r, i, d[n + 8], 7, 1770035416)), f, r, d[n + 9], 12, -1958414417)), m, f, d[n + 10], 17, -42063)), i, m, d[n + 11], 22, -1990404162)), (r = md5_ff(r, (i = md5_ff(i, (m = md5_ff(m, f, r, i, d[n + 12], 7, 1804603682)), f, r, d[n + 13], 12, -40341101)), m, f, d[n + 14], 17, -1502002290)), i, m, d[n + 15], 22, 1236535329)), (r = md5_gg(r, (i = md5_gg(i, (m = md5_gg(m, f, r, i, d[n + 1], 5, -165796510)), f, r, d[n + 6], 9, -1069501632)), m, f, d[n + 11], 14, 643717713)), i, m, d[n + 0], 20, -373897302)), (r = md5_gg(r, (i = md5_gg(i, (m = md5_gg(m, f, r, i, d[n + 5], 5, -701558691)), f, r, d[n + 10], 9, 38016083)), m, f, d[n + 15], 14, -660478335)), i, m, d[n + 4], 20, -405537848)), (r = md5_gg(r, (i = md5_gg(i, (m = md5_gg(m, f, r, i, d[n + 9], 5, 568446438)), f, r, d[n + 14], 9, -1019803690)), m, f, d[n + 3], 14, -187363961)), i, m, d[n + 8], 20, 1163531501)), (r = md5_gg(r, (i = md5_gg(i, (m = md5_gg(m, f, r, i, d[n + 13], 5, -1444681467)), f, r, d[n + 2], 9, -51403784)), m, f, d[n + 7], 14, 1735328473)), i, m, d[n + 12], 20, -1926607734)), (r = md5_hh(r, (i = md5_hh(i, (m = md5_hh(m, f, r, i, d[n + 5], 4, -378558)), f, r, d[n + 8], 11, -2022574463)), m, f, d[n + 11], 16, 1839030562)), i, m, d[n + 14], 23, -35309556)), (r = md5_hh(r, (i = md5_hh(i, (m = md5_hh(m, f, r, i, d[n + 1], 4, -1530992060)), f, r, d[n + 4], 11, 1272893353)), m, f, d[n + 7], 16, -155497632)), i, m, d[n + 10], 23, -1094730640)), (r = md5_hh(r, (i = md5_hh(i, (m = md5_hh(m, f, r, i, d[n + 13], 4, 681279174)), f, r, d[n + 0], 11, -358537222)), m, f, d[n + 3], 16, -722521979)), i, m, d[n + 6], 23, 76029189)), (r = md5_hh(r, (i = md5_hh(i, (m = md5_hh(m, f, r, i, d[n + 9], 4, -640364487)), f, r, d[n + 12], 11, -421815835)), m, f, d[n + 15], 16, 530742520)), i, m, d[n + 2], 23, -995338651)), (r = md5_ii(r, (i = md5_ii(i, (m = md5_ii(m, f, r, i, d[n + 0], 6, -198630844)), f, r, d[n + 7], 10, 1126891415)), m, f, d[n + 14], 15, -1416354905)), i, m, d[n + 5], 21, -57434055)), (r = md5_ii(r, (i = md5_ii(i, (m = md5_ii(m, f, r, i, d[n + 12], 6, 1700485571)), f, r, d[n + 3], 10, -1894986606)), m, f, d[n + 10], 15, -1051523)), i, m, d[n + 1], 21, -2054922799)), (r = md5_ii(r, (i = md5_ii(i, (m = md5_ii(m, f, r, i, d[n + 8], 6, 1873313359)), f, r, d[n + 15], 10, -30611744)), m, f, d[n + 6], 15, -1560198380)), i, m, d[n + 13], 21, 1309151649)), (r = md5_ii(r, (i = md5_ii(i, (m = md5_ii(m, f, r, i, d[n + 4], 6, -145523070)), f, r, d[n + 11], 10, -1120210379)), m, f, d[n + 2], 15, 718787259)), i, m, d[n + 9], 21, -343485551)),
            (m = safe_add(m, h)),
            (f = safe_add(f, t)),
            (r = safe_add(r, g)),
            (i = safe_add(i, e));
    }
    return [m, f, r, i];
}
function md5_cmn(d, _, m, f, r, i) {
    return safe_add(bit_rol(safe_add(safe_add(_, d), safe_add(f, i)), r), m);
}
function md5_ff(d, _, m, f, r, i, n) {
    return md5_cmn((_ & m) | (~_ & f), d, _, r, i, n);
}
function md5_gg(d, _, m, f, r, i, n) {
    return md5_cmn((_ & f) | (m & ~f), d, _, r, i, n);
}
function md5_hh(d, _, m, f, r, i, n) {
    return md5_cmn(_ ^ m ^ f, d, _, r, i, n);
}
function md5_ii(d, _, m, f, r, i, n) {
    return md5_cmn(m ^ (_ | ~f), d, _, r, i, n);
}
function safe_add(d, _) {
    const m = (65535 & d) + (65535 & _);
    return (((d >> 16) + (_ >> 16) + (m >> 16)) << 16) | (65535 & m);
}
function bit_rol(d, _) {
    return (d << _) | (d >>> (32 - _));
}
function updateContent(langData, langDataEn) {
    document.querySelectorAll('[data-i18n]').forEach(element => {
        const key = element.getAttribute('data-i18n');
        if (langData.hasOwnProperty(key))
            element.textContent = langData[key];
        else if (langDataEn.hasOwnProperty(key))
            element.textContent = langDataEn[key];
    });
}
async function setLanguagePreference(lang) {
    localStorage.setItem('language', lang);
    location.reload();
}
async function fetchLanguageData(lang) {
    const response = await fetch(`lang/${lang}.json`);
    return response.json();
}
async function changeLanguage(lang) {
    await setLanguagePreference(lang);
    const langData = await fetchLanguageData(lang);
    const langDataEn = await fetchLanguageData('en');
    updateContent(langData, langDataEn);
}
const value = 'test';
const nv = window.navigator;
const basic_key = [
    { t: 'A', v: 0x0004 },
    { t: 'B', v: 0x0005 },
    { t: 'C', v: 0x0006 },
    { t: 'D', v: 0x0007 },
    { t: 'E', v: 0x0008 },
    { t: 'F', v: 0x0009 },
    { t: 'G', v: 0x000a },
    { t: 'H', v: 0x000b },
    { t: 'I', v: 0x000c },
    { t: 'J', v: 0x000d },
    { t: 'K', v: 0x000e },
    { t: 'L', v: 0x000f },
    { t: 'M', v: 0x0010 },
    { t: 'N', v: 0x0011 },
    { t: 'O', v: 0x0012 },
    { t: 'P', v: 0x0013 },
    { t: 'Q', v: 0x0014 },
    { t: 'R', v: 0x0015 },
    { t: 'S', v: 0x0016 },
    { t: 'T', v: 0x0017 },
    { t: 'U', v: 0x0018 },
    { t: 'V', v: 0x0019 },
    { t: 'W', v: 0x001a },
    { t: 'X', v: 0x001b },
    { t: 'Y', v: 0x001c },
    { t: 'Z', v: 0x001d },
    { t: '1', v: 0x001e },
    { t: '2', v: 0x001f },
    { t: '3', v: 0x0020 },
    { t: '4', v: 0x0021 },
    { t: '5', v: 0x0022 },
    { t: '6', v: 0x0023 },
    { t: '7', v: 0x0024 },
    { t: '8', v: 0x0025 },
    { t: '9', v: 0x0026 },
    { t: '0', v: 0x0027 },
    { t: '-', v: 0x002d },
    { t: '=', v: 0x002e },
    { t: '[', v: 0x002f },
    { t: ']', v: 0x0030 },
    { t: '\\', v: 0x0031, tp: 'Backslash' },
    { t: ';', v: 0x0033 },
    { t: "'", v: 0x0034 },
    { t: '~', t2: '`', v: 0x0035 },
    { t: ',', v: 0x0036 },
    { t: '.', v: 0x0037 },
    { t: '/', v: 0x0038 },
    { t: 'ISO', t2: '\\', v: 0x0064, tp: 'ISO Backslash' },
    { t: 'ISO', t2: '#', v: 0x0032, tp: 'ISO #' },
    { t: 'JP', t2: '\\', v: 0x0087, tp: 'JP Backslash' },
];
const advan_key = [
    { t: ' ', v: 0x0000, tp: 'Nothing' },
    { t: '▽', v: 0x0001, tp: 'Pass-through' },
    { t: 'Esc', v: 0x0029 },
    { t: 'Tab', v: 0x002b },
    { t: 'Caps', v: 0x0039 },
    { t: 'Back', t2: 'space', v: 0x002a },
    { t: 'Enter', v: 0x0028 },
    { t: 'Space', t2: 'bar', v: 0x002c },
    { t: 'L-Ctrl', v: 0x00e0, tp: 'Left Control' },
    { t: 'R-Ctrl', v: 0x00e4, tp: 'Right Control' },
    { t: 'L-Shift', v: 0x00e1, tp: 'Left Shift' },
    { t: 'R-Shift', v: 0x00e5, tp: 'Right Shift' },
    { t: 'L-Alt', v: 0x00e2, tp: 'Left Alt(Options)' },
    { t: 'R-Alt', v: 0x00e6, tp: 'Right Alt(Options)' },
    { t: 'L-Win', v: 0x00e3, tp: 'Left Win(Command)' },
    { t: 'R-Win', v: 0x00e7, tp: 'Right Win(Command)' },
    { t: 'Menu', v: 0x0065 },
    { t: '無変換', v: 0x008b, tp: 'JP Muhenkan' },
    { t: '変換', v: 0x008a, tp: 'JP Henkan' },
    { t: 'かな', v: 0x0088, tp: 'JP Katakana ↔ Hiragana ↔ Rōmaji' },
    { t: "<mdui-icon name='arrow_forward' style='font-size: 16px;'></mdui-icon>", v: 0x004f },
    { t: "<mdui-icon name='arrow_back' style='font-size: 16px;'></mdui-icon>", v: 0x0050 },
    { t: "<mdui-icon name='arrow_downward' style='font-size: 16px;'></mdui-icon>", v: 0x0051 },
    { t: "<mdui-icon name='arrow_upward' style='font-size: 16px;'></mdui-icon>", v: 0x0052 },
    { t: 'PrtScr', v: 0x0046, tp: 'PrintScreen' },
    { t: 'ScrLck', v: 0x0047, tp: 'Scroll Lock' },
    { t: 'Pause', v: 0x0048, tp: 'Pause Break' },
    { t: 'Insert', v: 0x0049 },
    { t: 'Delete', v: 0x004c },
    { t: 'Home', v: 0x004a },
    { t: 'End', v: 0x004d },
    { t: 'Page', t2: 'Up', v: 0x004b },
    { t: 'Page', t2: 'Down', v: 0x004e },
    { t: 'F1', v: 0x003a },
    { t: 'F2', v: 0x003b },
    { t: 'F3', v: 0x003c },
    { t: 'F4', v: 0x003d },
    { t: 'F5', v: 0x003e },
    { t: 'F6', v: 0x003f },
    { t: 'F7', v: 0x0040 },
    { t: 'F8', v: 0x0041 },
    { t: 'F9', v: 0x0042 },
    { t: 'F10', v: 0x0043 },
    { t: 'F11', v: 0x0044 },
    { t: 'F12', v: 0x0045 },
    { t: 'F13', v: 0x0068 },
    { t: 'F14', v: 0x0069 },
    { t: 'F15', v: 0x006a },
    { t: 'F16', v: 0x006b },
    { t: 'F17', v: 0x006c },
    { t: 'F18', v: 0x006d },
    { t: 'F19', v: 0x006e },
    { t: 'F20', v: 0x006f },
    { t: 'F21', v: 0x0070 },
    { t: 'F22', v: 0x0071 },
    { t: 'F23', v: 0x0072 },
    { t: 'F24', v: 0x0073 },
    { t: 'Num', t2: 'Lock', v: 0x0053, tp: 'Numpad Lock' },
    { t: 'Num', t2: '+', v: 0x0057, tp: 'Numpad Plus' },
    { t: 'Num', t2: '-', v: 0x0056, tp: 'Numpad Minus' },
    { t: 'Num', t2: '*', v: 0x0055, tp: 'Numpad Multiply' },
    { t: 'Num', t2: '/', v: 0x0054, tp: 'Numpad Divide' },
    { t: 'Num', t2: '=', v: 0x0057, tp: 'Numpad Equal' },
    { t: 'Num', t2: '.', v: 0x0063, tp: 'Numpad Decimal' },
    { t: 'Num', t2: 'Enter', v: 0x0058, tp: 'Numpad Enter' },
    { t: 'Num', t2: '1', v: 0x0059, tp: 'Numpad 1' },
    { t: 'Num', t2: '2', v: 0x005a, tp: 'Numpad 2' },
    { t: 'Num', t2: '3', v: 0x005b, tp: 'Numpad 3' },
    { t: 'Num', t2: '4', v: 0x005c, tp: 'Numpad 4' },
    { t: 'Num', t2: '5', v: 0x005d, tp: 'Numpad 5' },
    { t: 'Num', t2: '6', v: 0x005e, tp: 'Numpad 6' },
    { t: 'Num', t2: '7', v: 0x005f, tp: 'Numpad 7' },
    { t: 'Num', t2: '8', v: 0x0060, tp: 'Numpad 8' },
    { t: 'Num', t2: '9', v: 0x0061, tp: 'Numpad 9' },
    { t: 'Num', t2: '0', v: 0x0062, tp: 'Numpad 0' },
    { t: 'Esc', t2: '`', v: 0x0029, v2: 0x0003, v3: 0x0035, tp: "Esc when hold nothing, ` when hold GUI, ~ when hold shift", ver: "option-ver-36" },
];
const speci_key = [
    {
        t: "<mdui-icon name='volume_off' style='font-size: 16px;'></mdui-icon>",
        v: 0x00a8,
        tp: 'Audio Mute',
    },
    {
        t: "<mdui-icon name='volume_down' style='font-size: 16px;'></mdui-icon>",
        v: 0x00aa,
        tp: 'Audio Volume Down',
    },
    {
        t: "<mdui-icon name='volume_up' style='font-size: 16px;'></mdui-icon>",
        v: 0x00a9,
        tp: 'Audio Volume Up',
    },
    {
        t: "<mdui-icon name='fast_forward' style='font-size: 16px;'></mdui-icon>",
        v: 0x00ab,
        tp: 'Next Track',
    },
    {
        t: "<mdui-icon name='fast_rewind' style='font-size: 16px;'></mdui-icon>",
        v: 0x00ac,
        tp: 'Previous Track',
    },
    { t: "<mdui-icon name='stop' style='font-size: 16px;'></mdui-icon>", v: 0x00ad, tp: 'Stop' },
    {
        t: "<mdui-icon name='play_arrow' style='font-size: 16px;'></mdui-icon><mdui-icon name='pause' style='margin-left:-7px; font-size: 16px;'></mdui-icon>",
        v: 0x00ae,
        tp: 'Play Pause',
    },
    { t: 'Media', t2: 'Select', v: 0x00af },
    { t: 'Media', t2: 'Eject', v: 0x00b0 },
    { t: "<mdui-icon name='mail' style='font-size: 16px;'></mdui-icon>", v: 0x00b1, tp: 'Mail' },
    {
        t: "<mdui-icon name='calculate' style='font-size: 16px;'></mdui-icon>",
        v: 0x00b2,
        tp: 'Calculator',
    },
    {
        t: "<mdui-icon name='computer' style='font-size: 16px;'></mdui-icon>",
        v: 0x00b3,
        tp: 'My Computer',
    },
    {
        t: "<mdui-icon name='search' style='font-size: 16px;'></mdui-icon>",
        t2: 'Web',
        v: 0x00b4,
        tp: 'Web Search',
    },
    {
        t: "<mdui-icon name='home' style='font-size: 16px;'></mdui-icon>",
        t2: 'Web',
        v: 0x00b5,
        tp: 'Web Home',
    },
    {
        t: "<mdui-icon name='fast_rewind' style='font-size: 16px;'></mdui-icon>",
        t2: 'Web',
        v: 0x00b6,
        tp: 'Web Back',
    },
    {
        t: "<mdui-icon name='fast_forward' style='font-size: 16px;'></mdui-icon>",
        t2: 'Web',
        v: 0x00b7,
        tp: 'Web Forward',
    },
    {
        t: "<mdui-icon name='stop' style='font-size: 16px;'></mdui-icon>",
        t2: 'Web',
        v: 0x00b8,
        tp: 'Web Stop',
    },
    {
        t: "<mdui-icon name='refresh' style='font-size: 16px;'></mdui-icon>",
        t2: 'Web',
        v: 0x00b9,
        tp: 'Web Refresh',
    },
    {
        t: "<mdui-icon name='bookmark' style='font-size: 16px;'></mdui-icon>",
        t2: 'Web',
        v: 0x00ba,
        tp: 'Web Bookmark',
    },
    {
        t: "<mdui-icon name='brightness_low' style='font-size: 16px;'></mdui-icon>",
        v: 0x00be,
        tp: 'Decrease Brightness',
    },
    {
        t: "<mdui-icon name='brightness_high' style='font-size: 16px;'></mdui-icon>",
        v: 0x00bd,
        tp: 'Increase Brightness',
    },
    { t: 'Mission', t2: 'Control', v: 0x00c1 },
    { t: 'MacOS', t2: 'Launch', v: 0x00c2, tp: 'MacOS Launchpad' },
    { t: 'System', t2: 'Power', v: 0x00a5 },
    { t: 'System', t2: 'Sleep', v: 0x00a6 },
    { t: 'System', t2: 'Wake', v: 0x00a7 },
];
const layer_key = [
    { t: '▽', v: 0x0001, tp: 'Pass-through' },
    { t: 'MO(1)', v: 0x5221, tp: 'Turn on Layer 1 when holding' },
    { t: 'MO(2)', v: 0x5222, tp: 'Turn on Layer 2 when holding' },
    { t: 'MO(3)', v: 0x5223, tp: 'Turn on Layer 3 when holding' },
    { t: 'DF(0)', v: 0x5240, tp: 'Set Layer 0 as default layer' },
    { t: 'DF(1)', v: 0x5241, tp: 'Set Layer 1 as default layer' },
    { t: 'DF(2)', v: 0x5242, tp: 'Set Layer 2 as default layer' },
    { t: 'DF(3)', v: 0x5243, tp: 'Set Layer 3 as default layer' },
    { t: 'TG(0)', v: 0x5260, tp: 'Toggle Layer 0 on/off' },
    { t: 'TG(1)', v: 0x5261, tp: 'Toggle Layer 1 on/off' },
    { t: 'TG(2)', v: 0x5262, tp: 'Toggle Layer 2 on/off' },
    { t: 'TG(3)', v: 0x5263, tp: 'Toggle Layer 3 on/off' },
];
const skb_key = [
    { t: 'Profile 0', v: 0x0000, v2: 0x00f0 },
    { t: 'Profile 1', v: 0x0001, v2: 0x00f0 },
    { t: 'Profile 2', v: 0x0002, v2: 0x00f0 },
    { t: 'Profile 3', v: 0x0003, v2: 0x00f0 },
    { t: 'NKRO', t2: 'OFF', v: 0x7011 },
    { t: 'NKRO', t2: 'ON', v: 0x7012 },
    { t: 'NKRO', t2: 'TOGGLE', v: 0x7013 },
];
let is_dark_mode = 1;
const font_size = '12px';
let hidList;
let hidDevice;
let fw;
let rx = 0;
let usb_listener_flag = 0;
let is_keyboard = 0;
let interval = null;
let interval_halt = 0;
let tab_selection = 0;
let kb_profile = 0;
let kb_layer = 0;
let link_profile = 0;
let divKey, divRemap;
let is_sel = new Uint8Array(128);
let element_mapping = new Uint8Array(128);
let sel_vec = [];
let is_default_slider = 1;
let toggle_keybind = 0;
const MAX_KB_LAYER = 4;
const ADV_MAP = 8;
let loadKBstop = 1;
let KB_KEYTYPE = new Uint16Array(MAX_KB_LAYER * 128);
let KB_KEYCODE = new Uint16Array(MAX_KB_LAYER * 128);
let KB_SETTING = new Uint16Array(MAX_KB_LAYER * 128);
let KB_ADV_MAP = new Uint16Array(ADV_MAP * 16);
let kb_layout = 0;
let kb_layout_support = 0;
let serial_num = new Uint8Array(64);
let serial_num_len = 0;
let fw_version = new Uint8Array(64);
let fw_version_len = 0;
let fw_number = 0;
let fw_json;
let new_fw_number = 0;
let curr_fw_build = "stable";
let new_fw_build = "stable";
let fw_tar_build = "stable";
let remap_mode = 0;
let advTap_sel = 0;
let advmod_addr = -1;
let kb_act_min = 2;
let kb_act_max = 80;
let kb_act_div = 20;
let raw_enable = 0;
let ap_dis = new Uint8Array(128);
let rt_up = new Uint8Array(128);
let rt_dn = new Uint8Array(128);
let rt_mode = new Uint8Array(128);
let deadzone = new Uint8Array(128);
let ap_dis_dual = new Uint8Array(128);
let is_global = new Uint8Array(128);
let is_jade = new Uint8Array(128);
let raw_matrix = new Uint8Array(128);
let raw_matrix_mark = new Uint8Array(128);
let val_adc = new Uint16Array(128);
let dist = new Uint8Array(128);
let rt_link = new Uint8Array(128);
let socd_key = new Uint8Array(128);
let socd_mode = new Uint8Array(128);
let auto_calibrate = 0;
let is_nkro = 0;
for (let i = 0; i < 128; ++i) {
    is_sel[i] = 0;
    ap_dis[i] = 0;
    rt_up[i] = 0;
    rt_dn[i] = 0;
    rt_mode[i] = 0;
    is_global[i] = 1;
    is_jade[i] = 0;
    raw_matrix[i] = 0;
    raw_matrix_mark[i] = 0;
    val_adc[i] = 4095;
    dist[i] = 0;
    rt_link[i] = 1;
    socd_key[i] = 0;
    socd_mode[i] = 0;
}
for (let i = 0; i < MAX_KB_LAYER * 128; ++i) {
    KB_KEYTYPE[i] = 0;
    KB_KEYCODE[i] = 0;
    KB_SETTING[i] = 0;
}
for (let i = 0; i < ADV_MAP * 16; ++i) {
    KB_ADV_MAP[i] = 0;
}
document.addEventListener('DOMContentLoaded', async function (event) {
    const userPreferredLanguage = localStorage.getItem('language') || 'en';
    const langData = await fetchLanguageData(userPreferredLanguage);
    const langDataEn = await fetchLanguageData('en');
    updateContent(langData, langDataEn);
    const switch_lang = document.getElementById('switch_lang');
    switch_lang.addEventListener('change', async function (event) {
        console.log(switch_lang.value);
        if (typeof switch_lang.value === "string") {
            if (userPreferredLanguage != switch_lang.value)
                changeLanguage(switch_lang.value);
        }
    });
    async function getTranslation(key) {
        if (langData.hasOwnProperty(key)) {
            let a = langData[key];
            return a;
        }
        else if (langDataEn.hasOwnProperty(key)) {
            let a = langDataEn[key];
            return a;
        }
    }
    switch_lang.value = userPreferredLanguage;
    class HIDQueue {
        constructor(device) {
            this.queue = [];
            this.isProcessing = false;
            this.currentNumber = 0;
            this.command_id = 0;
            this.device = device;
            if (this.handleInputReportBound) {
                this.device.removeEventListener('inputreport', this.handleInputReportBound);
            }
            this.handleInputReportBound = this.handleInputReport.bind(this);
            this.device.addEventListener('inputreport', this.handleInputReportBound);
        }
        enqueue(data) {
            const number = this.generateNumber();
            const item = { number, data };
            this.queue.push(item);
            this.processQueue();
        }
        generateNumber() {
            const number = this.currentNumber;
            this.currentNumber = (this.currentNumber + 1) % 65536;
            return number;
        }
        async processQueue() {
            if (this.isProcessing) {
                return;
            }
            this.isProcessing = true;
            while (this.queue.length > 0) {
                const item = this.queue.shift();
                if (item && this.device) {
                    try {
                        if (item.data[0] != 0) {
                            this.command_id = 0;
                            if (hidDevice.opened) {
                                await this.device.sendReport(0, item.data);
                                const timeoutPromise = new Promise((_, reject) => {
                                    setTimeout(() => {
                                        reject(new Error(`Timeout with command : ${item.data.slice(0, 12)}....`));
                                    }, 2000);
                                });
                                await Promise.race([this.waitForResult(item.data[0]), timeoutPromise]);
                            }
                            else {
                                console.error("Error processing item due to hidDevice is not opened");
                            }
                            this.command_id = 0;
                        }
                    }
                    catch (error) {
                        console.error('Error processing item:', error);
                    }
                }
            }
            this.isProcessing = false;
        }
        async waitForResult(command) {
            while ((this.command_id != command) && (this.command_id != 255)) {
                await new Promise((resolve) => setTimeout(resolve, 1));
            }
        }
        ;
        handleInputReport(event) {
            let bytearr = new Uint8Array(event.data.buffer);
            this.command_id = bytearr[0];
            SKBAPI(bytearr);
        }
        isBusy() {
            return this.isProcessing;
        }
    }
    let myQueue;
    const landpage = document.getElementById('landpage');
    const configurator = document.getElementById('configurator');
    const divKB = document.getElementById('divKB');
    const device_info = document.getElementById('device_info');
    const serial_info = document.getElementById('serial_info');
    const tab_sel = document.getElementById('tab-selection');
    let tab_sel_prev = 'tab-1';
    const layer = document
        .getElementById('layer').getElementsByTagName('div')[0]
        .getElementsByTagName('mdui-button');
    const prof = document
        .getElementById('prof')
        .getElementsByTagName('mdui-button');
    const linkprof = document.getElementById('linkprof');
    const skb_setting_div = document.getElementById('skb_setting_div');
    const advMod = document.getElementById('advMod');
    const advTap = document.getElementById('advTap');
    const divMod = document.getElementById('divMod');
    const divTap = document.getElementById('divTap');
    const advTap1 = document.getElementById('advTap1');
    const advTap2 = document.getElementById('advTap2');
    const advModKey = document.getElementsByClassName('advModKey');
    let advTapval1 = 0;
    let advTapval2 = 0;
    const showKeyBind = document.getElementById('showKeyBind');
    const deselectedAll = document.getElementById('deselectedAll');
    const resetToGlobal = document.getElementById('resetToGlobal');
    const resetAllToGlobal = document.getElementById('resetAllToGlobal');
    const actValue = document.getElementById('actValue');
    const actuationSlider = document.getElementById('actuationSlider');
    const rtUpValue = document.getElementById('rtUpValue');
    const rtUpSlider = document.getElementById('rtUpSlider');
    const rtDnValue = document.getElementById('rtDnValue');
    const rtDnSlider = document.getElementById('rtDnSlider');
    const deadzoneValue = document.getElementById('deadzoneValue');
    const deadzoneSlider = document.getElementById('deadzoneSlider');
    const RTSw = document.getElementById('RTSw');
    const RTConn = document.getElementById('RTConn');
    const keytest = document.getElementById('keytest');
    const keytest2 = document.getElementById('keytest2');
    const swSelect = document.getElementById('swSelect');
    const curr_switch = document.getElementById('curr_switch');
    const rawSw = document.getElementById('rawSw');
    const resetKeypress = document.getElementById('resetKeypress');
    const recalibratebtn = document.getElementById('recalibratebtn');
    const autoCalSW = document.getElementById('autoCalSW');
    const socd_mode_1 = document.getElementById('socd_mode_1');
    const socd_mode_2 = document.getElementById('socd_mode_2');
    const socd_mode_3 = document.getElementById('socd_mode_3');
    const socd_mode_41 = document.getElementById('socd_mode_41');
    const socd_mode_42 = document.getElementById('socd_mode_42');
    const socd_both_bottom_out = document.getElementById('socd_both_bottom_out');
    const socd_mode_41_head = document.getElementById('socd_mode_41_head');
    const socd_mode_42_head = document.getElementById('socd_mode_42_head');
    let socd_key_text_41 = "";
    let socd_key_text_42 = "";
    const e1 = document.getElementById("socd_key_1");
    const e2 = document.getElementById("socd_key_2");
    const isNKROSw = document.getElementById('isNKROSw');
    const factoryreset = document.getElementById('factoryreset');
    const swlayout = document.getElementById('swlayout');
    let keyboardjson = { layout1: { layout1_0_arr: [], layout1_1_arr: [] } };
    const fwupdatebtndrawer = document.getElementById('fwupdatebtndrawer');
    fwupdatebtndrawer.addEventListener('click', async function () {
        fw_tar_build = "stable";
        version_sel.value = fw_tar_build;
        await updateUI();
        firmwaredialog.open = true;
    });
    const firmwaredialog = document.getElementById('firmwaredialog');
    const openfirmwaredialog = document.getElementById('openfirmwaredialog');
    const closefirmwaredialog = document.getElementById('closefirmwaredialog');
    openfirmwaredialog.addEventListener('click', async function () {
        fw_tar_build = "stable";
        version_sel.value = fw_tar_build;
        await updateUI();
        firmwaredialog.open = true;
    });
    closefirmwaredialog.addEventListener('click', () => (firmwaredialog.open = false));
    const popupdialog = document.getElementById('popupdialog');
    const popupdialogMod = document.getElementById('popupdialogMod');
    const popupdialogTap = document.getElementById('popupdialogTap');
    const popupinner = document.getElementById('popupinner');
    const version_sel = document.getElementById('version_sel');
    const currfwtextdrawer = document.getElementById('currfwtextdrawer');
    const connectFWUpdate = document.getElementById('connectFWUpdate');
    const currfwtext = document.getElementById('currfwtext');
    const newfwtext = document.getElementById('newfwtext');
    const startupdate = document.getElementById("startupdate");
    const enteriap = document.getElementById("enteriap");
    const exitiap = document.getElementById("exitiap");
    const ui = document.getElementById('ui');
    const lightSw = document.getElementById('lightSw');
    const venomhe_img_light = document.getElementById("venomhe_img_light");
    const venomhe_img_dark = document.getElementById("venomhe_img_dark");
    const avater_light = document.getElementById("avater_light");
    const avater_dark = document.getElementById("avater_dark");
    lightSw.addEventListener('click', function () {
        if (is_dark_mode) {
            is_dark_mode = 0;
            ui.classList.add('mdui-theme-light');
            ui.classList.remove('mdui-theme-dark');
            lightSw.icon = 'light_mode';
            venomhe_img_light.setAttribute('style', 'display: block');
            venomhe_img_dark.setAttribute('style', 'display: none');
            avater_light.setAttribute('style', 'margin: 2px 2px 2px 2px; border: none;');
            avater_dark.setAttribute('style', 'margin: 2px 2px 2px 2px; border: none; display: none');
        }
        else {
            is_dark_mode = 1;
            ui.classList.remove('mdui-theme-light');
            ui.classList.add('mdui-theme-dark');
            lightSw.icon = 'dark_mode';
            venomhe_img_light.setAttribute('style', 'display: none');
            venomhe_img_dark.setAttribute('style', 'display: block');
            avater_light.setAttribute('style', 'margin: 2px 2px 2px 2px; border: none; display: none');
            avater_dark.setAttribute('style', 'margin: 2px 2px 2px 2px; border: none;');
        }
        localStorage.setItem('is_dark_mode', is_dark_mode.toString());
    });
    if (localStorage.getItem('is_dark_mode') != null) {
        is_dark_mode = parseInt(localStorage.getItem('is_dark_mode'));
        if (is_dark_mode) {
            ui.classList.remove('mdui-theme-light');
            ui.classList.add('mdui-theme-dark');
            lightSw.icon = 'dark_mode';
            venomhe_img_light.setAttribute('style', 'display: none');
            venomhe_img_dark.setAttribute('style', 'display: block');
            avater_light.setAttribute('style', 'margin: 2px 2px 2px 2px; border: none; display: none');
            avater_dark.setAttribute('style', 'margin: 2px 2px 2px 2px; border: none;');
        }
        else {
            ui.classList.add('mdui-theme-light');
            ui.classList.remove('mdui-theme-dark');
            lightSw.icon = 'light_mode';
            venomhe_img_light.setAttribute('style', 'display: block');
            venomhe_img_dark.setAttribute('style', 'display: none');
            avater_light.setAttribute('style', 'margin: 2px 2px 2px 2px; border: none;');
            avater_dark.setAttribute('style', 'margin: 2px 2px 2px 2px; border: none; display: none');
        }
        ui.hidden = false;
    }
    else {
        localStorage.setItem('is_dark_mode', '1');
        ui.hidden = false;
    }
    if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
        const mobilelandpage = document.getElementById('mobilelandpage');
        mobilelandpage.hidden = false;
        landpage.hidden = true;
        configurator.hidden = true;
        console.log('mobile device');
        throw '';
    }
    await createKeyboardjson(12545);
    await createremap();
    updateKB();
    updateUI();
    async function createKeyboardjson(productId) {
        const response = await window.fetch(window.location.href + 'skb/layout/' + productId.toString() + '.json', {
            method: 'GET',
        });
        const r = new FileReader();
        if (response.ok) {
            const r = await response.blob();
            const jsonlayout = JSON.parse(await r.text());
            console.log(`Load layout : ${jsonlayout.keyboard}`);
            keyboardjson = JSON.parse(await r.text());
            let keycount = 0;
            let key_size = 100;
            divKB.innerHTML = '';
            let row;
            let row_gap;
            let key;
            let chk = 0;
            let newline = 0;
            await jsonlayout.layouts.keymap.forEach(async function (rowlayout) {
                newline = 1;
                rowlayout.forEach(async function (keylayout) {
                    chk = 1;
                    if (isJsonString(keylayout)) {
                        if (keylayout.hasOwnProperty('y')) {
                            const gap = keylayout.y * 4;
                            for (let i = 0; i < gap; ++i) {
                                row_gap = document.createElement('div');
                                row_gap.setAttribute('style', 'width: 100%;');
                                row_gap.className = 'space-0-25u-h';
                                divKB.append(row_gap);
                            }
                        }
                        else if (keylayout.hasOwnProperty('w')) {
                            key_size = keylayout.w * 100;
                        }
                        else if (keylayout.hasOwnProperty('x')) {
                            const gap = keylayout.x * 4;
                            for (let i = 0; i < gap; ++i) {
                                key = document.createElement('div');
                                key.setAttribute('style', 'display: inline-block');
                                key.className = 'space-0-25u-v';
                                row.append(key);
                            }
                        }
                    }
                    else {
                        if (newline) {
                            newline = 0;
                            row = document.createElement('div');
                            row.setAttribute('style', 'width: 100%;');
                            divKB.append(row);
                        }
                        key = document.createElement('div');
                        const size = `key-${new String(key_size)}u`;
                        key.innerHTML = `<mdui-tooltip disabled trigger="hover" close-delay="0">
                                <mdui-button data-value="${jsonlayout.key_address[keycount] - 1}" variant="tonal" class="${size} getKey" style="border-color: --mdui-color-primary-light!important; border-style: solid; border-width: 0px;">
                                    <div style="line-height: 1.4; font-size: ${font_size};">
                                        <div style="width: 100%;">
                                            ${jsonlayout.key_address[keycount] - 1}
                                        </div>
                                        <div style="width: 100%;">
                                            ${' '}
                                        </div>
                                        <div style="width: 100%;">
                                            ${' '}
                                        </div>
                                    </div>
                                </mdui-button>
                                <div class="tooltipslot" slot="content">
                                </div>
                            </mdui-tooltip>`;
                        key.className = 'btn-space';
                        let chk = 1;
                        kb_layout_support = 0;
                        if (fw_number >= 36) {
                            if (jsonlayout.hasOwnProperty("layout1")) {
                                kb_layout_support = 0x0001;
                                if ((kb_layout & 0x0001) == 0x0001) {
                                    jsonlayout.layout1.layout1_0_arr.forEach(async function (list) {
                                        if (list - 1 == jsonlayout.key_address[keycount] - 1) {
                                            chk = 0;
                                        }
                                    });
                                }
                                else {
                                    jsonlayout.layout1.layout1_1_arr.forEach(async function (list) {
                                        if (list - 1 == jsonlayout.key_address[keycount] - 1) {
                                            chk = 0;
                                        }
                                    });
                                }
                            }
                            if (jsonlayout.hasOwnProperty("layout2")) {
                                kb_layout_support = 0x0002;
                                if ((kb_layout & 0x0002) == 0x0002) {
                                    jsonlayout.layout2.layout2_0_arr.forEach(async function (list) {
                                        if (list - 1 == jsonlayout.key_address[keycount] - 1) {
                                            chk = 0;
                                        }
                                    });
                                }
                                else {
                                    jsonlayout.layout2.layout2_1_arr.forEach(async function (list) {
                                        if (list - 1 == jsonlayout.key_address[keycount] - 1) {
                                            chk = 0;
                                        }
                                    });
                                }
                            }
                            if (jsonlayout.hasOwnProperty("layout3")) {
                                kb_layout_support = 0x0004;
                                if ((kb_layout & 0x0004) == 0x0004) {
                                    jsonlayout.layout3.layout3_0_arr.forEach(async function (list) {
                                        if (list - 1 == jsonlayout.key_address[keycount] - 1) {
                                            chk = 0;
                                        }
                                    });
                                }
                                else {
                                    jsonlayout.layout3.layout3_1_arr.forEach(async function (list) {
                                        if (list - 1 == jsonlayout.key_address[keycount] - 1) {
                                            chk = 0;
                                        }
                                    });
                                }
                            }
                            if (jsonlayout.hasOwnProperty("layout4")) {
                                kb_layout_support = 0x0008;
                                if ((kb_layout & 0x0008) == 0x0008) {
                                    jsonlayout.layout4.layout4_0_arr.forEach(async function (list) {
                                        if (list - 1 == jsonlayout.key_address[keycount] - 1) {
                                            chk = 0;
                                        }
                                    });
                                }
                                else {
                                    jsonlayout.layout4.layout4_1_arr.forEach(async function (list) {
                                        if (list - 1 == jsonlayout.key_address[keycount] - 1) {
                                            chk = 0;
                                        }
                                    });
                                }
                            }
                        }
                        if (chk) {
                            row.append(key);
                        }
                        keycount += 1;
                        key_size = 100;
                    }
                });
            });
            divKey = document.querySelectorAll('.getKey');
            Array.from(divKey).forEach(function (element, i) {
                element_mapping[i] = parseInt(element.dataset.value);
                element.addEventListener('click', async function (event) {
                    switch (tab_selection) {
                        case 0:
                            if (is_sel[element_mapping[i]] == 1) {
                                is_sel[element_mapping[i]] = 0;
                            }
                            else {
                                is_sel.forEach(function (elem, j) {
                                    is_sel[j] = 0;
                                });
                                is_sel[element_mapping[i]] = 1;
                                console.log(`Remap : ${element_mapping[i]}`);
                            }
                            remap_mode = 0;
                            updateUI();
                            advMod.disabled = true;
                            advTap.disabled = true;
                            let addr = element_mapping[i] + kb_layer * 128;
                            if (KB_KEYCODE[addr] >= 0x0000 && KB_KEYCODE[addr] <= 0x1FFF && (KB_KEYTYPE[addr] == 1 || KB_KEYTYPE[addr] == 0) && is_sel[element_mapping[i]] == 1) {
                                advMod.disabled = false;
                                console.log(KB_KEYTYPE[addr], KB_KEYCODE[addr], KB_SETTING[addr]);
                            }
                            if (is_sel[element_mapping[i]] == 1) {
                                advTap.disabled = false;
                                if (KB_KEYTYPE[addr] == 2) {
                                    advTapval1 = KB_KEYCODE[addr];
                                    advTapval2 = KB_SETTING[addr];
                                }
                                else {
                                    advTapval1 = 0;
                                    advTapval2 = 0;
                                }
                                updateUITap(advTap1, advTapval1);
                                updateUITap(advTap2, advTapval2);
                            }
                            break;
                        case 1:
                            if (is_sel[element_mapping[i]] == 1) {
                                is_sel[element_mapping[i]] = 0;
                                sel_vec.forEach(async function (value, j) {
                                    if (sel_vec[j] == element_mapping[i]) {
                                        sel_vec.splice(j, 1);
                                    }
                                });
                            }
                            else {
                                is_sel[element_mapping[i]] = 1;
                                sel_vec.push(element_mapping[i]);
                            }
                            updateUI();
                            console.log(`Actuation Tab : ${sel_vec}`);
                            break;
                        case 12:
                            if (is_sel[element_mapping[i]] == 1) {
                                if (socd_mode[element_mapping[i]] == 0 && socd_mode[socd_key[element_mapping[i]]] == 0) {
                                    is_sel[element_mapping[i]] = 0;
                                    sel_vec.forEach(async function (value, j) {
                                        if (sel_vec[j] == element_mapping[i]) {
                                            sel_vec.splice(j, 1);
                                        }
                                    });
                                }
                                else {
                                    is_sel[element_mapping[i]] = 0;
                                    sel_vec.forEach(async function (value, j) {
                                        if (sel_vec[j] == element_mapping[i]) {
                                            sel_vec.splice(j, 1);
                                        }
                                    });
                                    is_sel[socd_key[element_mapping[i]]] = 0;
                                    sel_vec.forEach(async function (value, j) {
                                        if (sel_vec[j] == socd_key[element_mapping[i]]) {
                                            sel_vec.splice(j, 1);
                                        }
                                    });
                                }
                                if (sel_vec.length != 2) {
                                    e1.innerHTML = "Key 1";
                                    e2.innerHTML = "Key 2";
                                    if (sel_vec.length == 1) {
                                        for (let j = 0; j < 1; ++j) {
                                            let e = e1;
                                            const parent_tooltips = e.parentElement;
                                            parent_tooltips.disabled = true;
                                            let inner = `<div style="line-height: 1.4; font-size: ${font_size};">
                                    
                                </div>`;
                                            let line1 = '';
                                            let line2 = '';
                                            let line3 = '';
                                            let line4 = '';
                                            let found = 0;
                                            e.setAttribute('variant', 'tonal');
                                            let show_layer = 0;
                                            for (const elem of skb_key) {
                                                if (elem.v == KB_KEYCODE[sel_vec[j] + 128 * show_layer] &&
                                                    found == 0) {
                                                    if (elem.hasOwnProperty('v2')) {
                                                        if (elem.v2 == KB_KEYTYPE[sel_vec[j] + 128 * show_layer] &&
                                                            found == 0) {
                                                            found = 1;
                                                            if (elem.hasOwnProperty('t'))
                                                                line1 = elem.t;
                                                            if (elem.hasOwnProperty('t2'))
                                                                line2 = elem.t2;
                                                        }
                                                    }
                                                    else {
                                                        found = 1;
                                                        if (elem.hasOwnProperty('t'))
                                                            line1 = elem.t;
                                                        if (elem.hasOwnProperty('t2'))
                                                            line2 = elem.t2;
                                                    }
                                                }
                                                if (found)
                                                    break;
                                            }
                                            if (KB_KEYTYPE[sel_vec[j] + 128 * show_layer] == 0 || KB_KEYTYPE[sel_vec[j] + 128 * show_layer] == 1 || KB_KEYTYPE[sel_vec[j] + 128 * show_layer] == 2) {
                                                for (const elem of layer_key) {
                                                    if (elem.v == KB_KEYCODE[sel_vec[j] + 128 * show_layer] &&
                                                        found == 0) {
                                                        found = 1;
                                                        if (elem.hasOwnProperty('t'))
                                                            line1 = elem.t;
                                                    }
                                                    if (found)
                                                        break;
                                                }
                                                for (const elem of speci_key) {
                                                    if (elem.v == KB_KEYCODE[sel_vec[j] + 128 * show_layer] &&
                                                        found == 0) {
                                                        found = 1;
                                                        if (elem.hasOwnProperty('t'))
                                                            line1 = elem.t;
                                                        if (elem.hasOwnProperty('t2'))
                                                            line2 = elem.t2;
                                                    }
                                                    if (found)
                                                        break;
                                                }
                                                for (const elem of basic_key) {
                                                    if (elem.v == KB_KEYCODE[sel_vec[j] + 128 * show_layer] &&
                                                        found == 0) {
                                                        found = 1;
                                                        if (elem.hasOwnProperty('t'))
                                                            line1 = elem.t;
                                                        if (elem.hasOwnProperty('t2'))
                                                            line2 = elem.t2;
                                                    }
                                                    if (found)
                                                        break;
                                                }
                                                for (const elem of advan_key) {
                                                    if (elem.v == KB_KEYCODE[sel_vec[j] + 128 * show_layer] &&
                                                        found == 0) {
                                                        found = 1;
                                                        if (elem.hasOwnProperty('t'))
                                                            line1 = elem.t;
                                                        if (elem.hasOwnProperty('t2'))
                                                            line2 = elem.t2;
                                                    }
                                                    if (found)
                                                        break;
                                                }
                                            }
                                            if ((KB_KEYTYPE[sel_vec[j] + 128 * show_layer] == 0 || KB_KEYTYPE[sel_vec[j] + 128 * show_layer] == 1) && (KB_KEYCODE[sel_vec[j] + 128 * show_layer] >= 0x0100 && KB_KEYCODE[sel_vec[j] + 128 * show_layer] <= 0x1fff)) {
                                                for (const elem of layer_key) {
                                                    if (elem.v == (KB_KEYCODE[sel_vec[j] + 128 * show_layer] & 0x00ff) &&
                                                        found == 0) {
                                                        found = 1;
                                                        if (elem.hasOwnProperty('t'))
                                                            line1 = elem.t;
                                                    }
                                                    if (found)
                                                        break;
                                                }
                                                for (const elem of speci_key) {
                                                    if (elem.v == (KB_KEYCODE[sel_vec[j] + 128 * show_layer] & 0x00ff) &&
                                                        found == 0) {
                                                        found = 1;
                                                        if (elem.hasOwnProperty('t'))
                                                            line1 = elem.t;
                                                        if (elem.hasOwnProperty('t2'))
                                                            line2 = elem.t2;
                                                    }
                                                    if (found)
                                                        break;
                                                }
                                                for (const elem of basic_key) {
                                                    if (elem.v == (KB_KEYCODE[sel_vec[j] + 128 * show_layer] & 0x00ff) &&
                                                        found == 0) {
                                                        found = 1;
                                                        if (elem.hasOwnProperty('t'))
                                                            line1 = elem.t;
                                                        if (elem.hasOwnProperty('t2'))
                                                            line2 = elem.t2;
                                                    }
                                                    if (found)
                                                        break;
                                                }
                                                for (const elem of advan_key) {
                                                    if (elem.v == (KB_KEYCODE[sel_vec[j] + 128 * show_layer] & 0x00ff) &&
                                                        found == 0) {
                                                        found = 1;
                                                        if (elem.hasOwnProperty('t'))
                                                            line1 = elem.t;
                                                        if (elem.hasOwnProperty('t2'))
                                                            line2 = elem.t2;
                                                    }
                                                    if (found)
                                                        break;
                                                }
                                            }
                                            if (KB_KEYTYPE[sel_vec[j] + 128 * show_layer] == 2) {
                                                found = 0;
                                                for (const elem of layer_key) {
                                                    if (elem.v == KB_SETTING[sel_vec[j] + 128 * show_layer] &&
                                                        found == 0) {
                                                        found = 1;
                                                        if (elem.hasOwnProperty('t'))
                                                            line3 = elem.t;
                                                    }
                                                    if (found)
                                                        break;
                                                }
                                                for (const elem of speci_key) {
                                                    if (elem.v == KB_SETTING[sel_vec[j] + 128 * show_layer] &&
                                                        found == 0) {
                                                        found = 1;
                                                        if (elem.hasOwnProperty('t'))
                                                            line3 = elem.t;
                                                        if (elem.hasOwnProperty('t2'))
                                                            line4 = elem.t2;
                                                    }
                                                    if (found)
                                                        break;
                                                }
                                                for (const elem of basic_key) {
                                                    if (elem.v == KB_SETTING[sel_vec[j] + 128 * show_layer] &&
                                                        found == 0) {
                                                        found = 1;
                                                        if (elem.hasOwnProperty('t'))
                                                            line3 = elem.t;
                                                        if (elem.hasOwnProperty('t2'))
                                                            line4 = elem.t2;
                                                    }
                                                    if (found)
                                                        break;
                                                }
                                                for (const elem of advan_key) {
                                                    if (elem.v == KB_SETTING[sel_vec[j] + 128 * show_layer] &&
                                                        found == 0) {
                                                        found = 1;
                                                        if (elem.hasOwnProperty('t'))
                                                            line3 = elem.t;
                                                        if (elem.hasOwnProperty('t2'))
                                                            line4 = elem.t2;
                                                    }
                                                    if (found)
                                                        break;
                                                }
                                            }
                                            if (KB_KEYTYPE[sel_vec[j] + 128 * show_layer] == 1 || KB_KEYTYPE[sel_vec[j] + 128 * show_layer] == 0) {
                                                if (KB_KEYCODE[sel_vec[j] + 128 * show_layer] >= 0x0100 && KB_KEYCODE[sel_vec[j] + 128 * show_layer] <= 0x1fff) {
                                                    parent_tooltips.disabled = false;
                                                    parent_tooltips.querySelector('.tooltipslot').innerHTML = `<div>Modifier + ${line1}${line2}`;
                                                    inner = `<div style="line-height: 1.4; font-size: ${font_size};">
                                <div style="width: 100%;">
                                    MOD
                                </div>
                                <div style="width: 100%;">
                                    ${line1}
                                </div>
                                <div style="width: 100%;">
                                    ${line2}
                                </div>
                            </div>`;
                                                    if (j == 0)
                                                        socd_key_text_41 = `MOD ${line1} + ${line2}`;
                                                    else
                                                        socd_key_text_42 = `MOD ${line1} + ${line2}`;
                                                }
                                                else
                                                    inner = `<div style="line-height: 1.4; font-size: ${font_size};">
                                <div style="width: 100%;">
                                    ${line1}
                                </div>
                                <div style="width: 100%;">
  
                                </div>
                                <div style="width: 100%;">
                                    ${line2}
                                </div>
                            </div>`;
                                                if (j == 0)
                                                    socd_key_text_41 = `${line1} ${line2}`;
                                                else
                                                    socd_key_text_42 = `${line1} ${line2}`;
                                            }
                                            if (KB_KEYTYPE[sel_vec[j] + 128 * show_layer] == 0xf0) {
                                                inner = `<div style="line-height: 1.4; font-size: ${font_size};">
                              <div style="width: 100%;">
                                  ${line1}
                              </div>
                              <div style="width: 100%;">
  
                              </div>
                              <div style="width: 100%;">
                                  ${line2}
                              </div>
                          </div>`;
                                                if (j == 0)
                                                    socd_key_text_41 = `${line1} ${line2}`;
                                                else
                                                    socd_key_text_42 = `${line1} ${line2}`;
                                            }
                                            if (KB_KEYTYPE[sel_vec[j] + 128 * show_layer] == 2) {
                                                parent_tooltips.disabled = false;
                                                parent_tooltips.querySelector('.tooltipslot').innerHTML = `<div>Tap : ${line1}${line2}</div><div>Hold : ${line3}${line4}</div>`;
                                                inner = `<div style="line-height: 1.4; font-size: ${font_size};">
                              <div style="width: 100%;">
                                  TAP
                              </div>
                              <div style="width: 100%;">
                                  ${line1}
                              </div>
                              <div style="width: 100%;">
                                  ${line3}
                              </div>
                          </div>`;
                                                if (j == 0)
                                                    socd_key_text_41 = `TAP ${line1} ${line2}`;
                                                else
                                                    socd_key_text_42 = `TAP ${line1} ${line2}`;
                                            }
                                            e.innerHTML = inner;
                                        }
                                    }
                                    updateUI();
                                }
                            }
                            else {
                                if (socd_mode[element_mapping[i]] == 0 && socd_mode[socd_key[element_mapping[i]]] == 0) {
                                    if (sel_vec.length < 2) {
                                        is_sel[element_mapping[i]] = 1;
                                        sel_vec.push(element_mapping[i]);
                                        for (let j = 0; j < 1; ++j) {
                                            let e = e1;
                                            const parent_tooltips = e.parentElement;
                                            parent_tooltips.disabled = true;
                                            let inner = `<div style="line-height: 1.4; font-size: ${font_size};">
                                    
                                </div>`;
                                            let line1 = '';
                                            let line2 = '';
                                            let line3 = '';
                                            let line4 = '';
                                            let found = 0;
                                            e.setAttribute('variant', 'tonal');
                                            let show_layer = 0;
                                            for (const elem of skb_key) {
                                                if (elem.v == KB_KEYCODE[sel_vec[j] + 128 * show_layer] &&
                                                    found == 0) {
                                                    if (elem.hasOwnProperty('v2')) {
                                                        if (elem.v2 == KB_KEYTYPE[sel_vec[j] + 128 * show_layer] &&
                                                            found == 0) {
                                                            found = 1;
                                                            if (elem.hasOwnProperty('t'))
                                                                line1 = elem.t;
                                                            if (elem.hasOwnProperty('t2'))
                                                                line2 = elem.t2;
                                                        }
                                                    }
                                                    else {
                                                        found = 1;
                                                        if (elem.hasOwnProperty('t'))
                                                            line1 = elem.t;
                                                        if (elem.hasOwnProperty('t2'))
                                                            line2 = elem.t2;
                                                    }
                                                }
                                                if (found)
                                                    break;
                                            }
                                            if (KB_KEYTYPE[sel_vec[j] + 128 * show_layer] == 0 || KB_KEYTYPE[sel_vec[j] + 128 * show_layer] == 1 || KB_KEYTYPE[sel_vec[j] + 128 * show_layer] == 2) {
                                                for (const elem of layer_key) {
                                                    if (elem.v == KB_KEYCODE[sel_vec[j] + 128 * show_layer] &&
                                                        found == 0) {
                                                        found = 1;
                                                        if (elem.hasOwnProperty('t'))
                                                            line1 = elem.t;
                                                    }
                                                    if (found)
                                                        break;
                                                }
                                                for (const elem of speci_key) {
                                                    if (elem.v == KB_KEYCODE[sel_vec[j] + 128 * show_layer] &&
                                                        found == 0) {
                                                        found = 1;
                                                        if (elem.hasOwnProperty('t'))
                                                            line1 = elem.t;
                                                        if (elem.hasOwnProperty('t2'))
                                                            line2 = elem.t2;
                                                    }
                                                    if (found)
                                                        break;
                                                }
                                                for (const elem of basic_key) {
                                                    if (elem.v == KB_KEYCODE[sel_vec[j] + 128 * show_layer] &&
                                                        found == 0) {
                                                        found = 1;
                                                        if (elem.hasOwnProperty('t'))
                                                            line1 = elem.t;
                                                        if (elem.hasOwnProperty('t2'))
                                                            line2 = elem.t2;
                                                    }
                                                    if (found)
                                                        break;
                                                }
                                                for (const elem of advan_key) {
                                                    if (elem.v == KB_KEYCODE[sel_vec[j] + 128 * show_layer] &&
                                                        found == 0) {
                                                        found = 1;
                                                        if (elem.hasOwnProperty('t'))
                                                            line1 = elem.t;
                                                        if (elem.hasOwnProperty('t2'))
                                                            line2 = elem.t2;
                                                    }
                                                    if (found)
                                                        break;
                                                }
                                            }
                                            if ((KB_KEYTYPE[sel_vec[j] + 128 * show_layer] == 0 || KB_KEYTYPE[sel_vec[j] + 128 * show_layer] == 1) && (KB_KEYCODE[sel_vec[j] + 128 * show_layer] >= 0x0100 && KB_KEYCODE[sel_vec[j] + 128 * show_layer] <= 0x1fff)) {
                                                for (const elem of layer_key) {
                                                    if (elem.v == (KB_KEYCODE[sel_vec[j] + 128 * show_layer] & 0x00ff) &&
                                                        found == 0) {
                                                        found = 1;
                                                        if (elem.hasOwnProperty('t'))
                                                            line1 = elem.t;
                                                    }
                                                    if (found)
                                                        break;
                                                }
                                                for (const elem of speci_key) {
                                                    if (elem.v == (KB_KEYCODE[sel_vec[j] + 128 * show_layer] & 0x00ff) &&
                                                        found == 0) {
                                                        found = 1;
                                                        if (elem.hasOwnProperty('t'))
                                                            line1 = elem.t;
                                                        if (elem.hasOwnProperty('t2'))
                                                            line2 = elem.t2;
                                                    }
                                                    if (found)
                                                        break;
                                                }
                                                for (const elem of basic_key) {
                                                    if (elem.v == (KB_KEYCODE[sel_vec[j] + 128 * show_layer] & 0x00ff) &&
                                                        found == 0) {
                                                        found = 1;
                                                        if (elem.hasOwnProperty('t'))
                                                            line1 = elem.t;
                                                        if (elem.hasOwnProperty('t2'))
                                                            line2 = elem.t2;
                                                    }
                                                    if (found)
                                                        break;
                                                }
                                                for (const elem of advan_key) {
                                                    if (elem.v == (KB_KEYCODE[sel_vec[j] + 128 * show_layer] & 0x00ff) &&
                                                        found == 0) {
                                                        found = 1;
                                                        if (elem.hasOwnProperty('t'))
                                                            line1 = elem.t;
                                                        if (elem.hasOwnProperty('t2'))
                                                            line2 = elem.t2;
                                                    }
                                                    if (found)
                                                        break;
                                                }
                                            }
                                            if (KB_KEYTYPE[sel_vec[j] + 128 * show_layer] == 2) {
                                                found = 0;
                                                for (const elem of layer_key) {
                                                    if (elem.v == KB_SETTING[sel_vec[j] + 128 * show_layer] &&
                                                        found == 0) {
                                                        found = 1;
                                                        if (elem.hasOwnProperty('t'))
                                                            line3 = elem.t;
                                                    }
                                                    if (found)
                                                        break;
                                                }
                                                for (const elem of speci_key) {
                                                    if (elem.v == KB_SETTING[sel_vec[j] + 128 * show_layer] &&
                                                        found == 0) {
                                                        found = 1;
                                                        if (elem.hasOwnProperty('t'))
                                                            line3 = elem.t;
                                                        if (elem.hasOwnProperty('t2'))
                                                            line4 = elem.t2;
                                                    }
                                                    if (found)
                                                        break;
                                                }
                                                for (const elem of basic_key) {
                                                    if (elem.v == KB_SETTING[sel_vec[j] + 128 * show_layer] &&
                                                        found == 0) {
                                                        found = 1;
                                                        if (elem.hasOwnProperty('t'))
                                                            line3 = elem.t;
                                                        if (elem.hasOwnProperty('t2'))
                                                            line4 = elem.t2;
                                                    }
                                                    if (found)
                                                        break;
                                                }
                                                for (const elem of advan_key) {
                                                    if (elem.v == KB_SETTING[sel_vec[j] + 128 * show_layer] &&
                                                        found == 0) {
                                                        found = 1;
                                                        if (elem.hasOwnProperty('t'))
                                                            line3 = elem.t;
                                                        if (elem.hasOwnProperty('t2'))
                                                            line4 = elem.t2;
                                                    }
                                                    if (found)
                                                        break;
                                                }
                                            }
                                            if (KB_KEYTYPE[sel_vec[j] + 128 * show_layer] == 1 || KB_KEYTYPE[sel_vec[j] + 128 * show_layer] == 0) {
                                                if (KB_KEYCODE[sel_vec[j] + 128 * show_layer] >= 0x0100 && KB_KEYCODE[sel_vec[j] + 128 * show_layer] <= 0x1fff) {
                                                    parent_tooltips.disabled = false;
                                                    parent_tooltips.querySelector('.tooltipslot').innerHTML = `<div>Modifier + ${line1}${line2}`;
                                                    inner = `<div style="line-height: 1.4; font-size: ${font_size};">
                                <div style="width: 100%;">
                                    MOD
                                </div>
                                <div style="width: 100%;">
                                    ${line1}
                                </div>
                                <div style="width: 100%;">
                                    ${line2}
                                </div>
                            </div>`;
                                                    if (j == 0)
                                                        socd_key_text_41 = `MOD ${line1} + ${line2}`;
                                                    else
                                                        socd_key_text_42 = `MOD ${line1} + ${line2}`;
                                                }
                                                else
                                                    inner = `<div style="line-height: 1.4; font-size: ${font_size};">
                                <div style="width: 100%;">
                                    ${line1}
                                </div>
                                <div style="width: 100%;">
  
                                </div>
                                <div style="width: 100%;">
                                    ${line2}
                                </div>
                            </div>`;
                                                if (j == 0)
                                                    socd_key_text_41 = `${line1} ${line2}`;
                                                else
                                                    socd_key_text_42 = `${line1} ${line2}`;
                                            }
                                            if (KB_KEYTYPE[sel_vec[j] + 128 * show_layer] == 0xf0) {
                                                inner = `<div style="line-height: 1.4; font-size: ${font_size};">
                              <div style="width: 100%;">
                                  ${line1}
                              </div>
                              <div style="width: 100%;">
  
                              </div>
                              <div style="width: 100%;">
                                  ${line2}
                              </div>
                          </div>`;
                                                if (j == 0)
                                                    socd_key_text_41 = `${line1} ${line2}`;
                                                else
                                                    socd_key_text_42 = `${line1} ${line2}`;
                                            }
                                            if (KB_KEYTYPE[sel_vec[j] + 128 * show_layer] == 2) {
                                                parent_tooltips.disabled = false;
                                                parent_tooltips.querySelector('.tooltipslot').innerHTML = `<div>Tap : ${line1}${line2}</div><div>Hold : ${line3}${line4}</div>`;
                                                inner = `<div style="line-height: 1.4; font-size: ${font_size};">
                              <div style="width: 100%;">
                                  TAP
                              </div>
                              <div style="width: 100%;">
                                  ${line1}
                              </div>
                              <div style="width: 100%;">
                                  ${line3}
                              </div>
                          </div>`;
                                                if (j == 0)
                                                    socd_key_text_41 = `TAP ${line1} ${line2}`;
                                                else
                                                    socd_key_text_42 = `TAP ${line1} ${line2}`;
                                            }
                                            e.innerHTML = inner;
                                        }
                                    }
                                }
                                else {
                                    if (sel_vec.length == 0) {
                                        is_sel[element_mapping[i]] = 1;
                                        sel_vec.push(element_mapping[i]);
                                        is_sel[socd_key[element_mapping[i]]] = 1;
                                        sel_vec.push(socd_key[element_mapping[i]]);
                                    }
                                }
                                if (sel_vec.length == 2) {
                                    for (let j = 0; j < 2; ++j) {
                                        let e = e1;
                                        if (j == 1)
                                            e = e2;
                                        const parent_tooltips = e.parentElement;
                                        parent_tooltips.disabled = true;
                                        let inner = `<div style="line-height: 1.4; font-size: ${font_size};">
                                  
                              </div>`;
                                        let line1 = '';
                                        let line2 = '';
                                        let line3 = '';
                                        let line4 = '';
                                        let found = 0;
                                        e.setAttribute('variant', 'tonal');
                                        let show_layer = 0;
                                        for (const elem of skb_key) {
                                            if (elem.v == KB_KEYCODE[sel_vec[j] + 128 * show_layer] &&
                                                found == 0) {
                                                if (elem.hasOwnProperty('v2')) {
                                                    if (elem.v2 == KB_KEYTYPE[sel_vec[j] + 128 * show_layer] &&
                                                        found == 0) {
                                                        found = 1;
                                                        if (elem.hasOwnProperty('t'))
                                                            line1 = elem.t;
                                                        if (elem.hasOwnProperty('t2'))
                                                            line2 = elem.t2;
                                                    }
                                                }
                                                else {
                                                    found = 1;
                                                    if (elem.hasOwnProperty('t'))
                                                        line1 = elem.t;
                                                    if (elem.hasOwnProperty('t2'))
                                                        line2 = elem.t2;
                                                }
                                            }
                                            if (found)
                                                break;
                                        }
                                        if (KB_KEYTYPE[sel_vec[j] + 128 * show_layer] == 0 || KB_KEYTYPE[sel_vec[j] + 128 * show_layer] == 1 || KB_KEYTYPE[sel_vec[j] + 128 * show_layer] == 2) {
                                            for (const elem of layer_key) {
                                                if (elem.v == KB_KEYCODE[sel_vec[j] + 128 * show_layer] &&
                                                    found == 0) {
                                                    found = 1;
                                                    if (elem.hasOwnProperty('t'))
                                                        line1 = elem.t;
                                                }
                                                if (found)
                                                    break;
                                            }
                                            for (const elem of speci_key) {
                                                if (elem.v == KB_KEYCODE[sel_vec[j] + 128 * show_layer] &&
                                                    found == 0) {
                                                    found = 1;
                                                    if (elem.hasOwnProperty('t'))
                                                        line1 = elem.t;
                                                    if (elem.hasOwnProperty('t2'))
                                                        line2 = elem.t2;
                                                }
                                                if (found)
                                                    break;
                                            }
                                            for (const elem of basic_key) {
                                                if (elem.v == KB_KEYCODE[sel_vec[j] + 128 * show_layer] &&
                                                    found == 0) {
                                                    found = 1;
                                                    if (elem.hasOwnProperty('t'))
                                                        line1 = elem.t;
                                                    if (elem.hasOwnProperty('t2'))
                                                        line2 = elem.t2;
                                                }
                                                if (found)
                                                    break;
                                            }
                                            for (const elem of advan_key) {
                                                if (elem.v == KB_KEYCODE[sel_vec[j] + 128 * show_layer] &&
                                                    found == 0) {
                                                    found = 1;
                                                    if (elem.hasOwnProperty('t'))
                                                        line1 = elem.t;
                                                    if (elem.hasOwnProperty('t2'))
                                                        line2 = elem.t2;
                                                }
                                                if (found)
                                                    break;
                                            }
                                        }
                                        if ((KB_KEYTYPE[sel_vec[j] + 128 * show_layer] == 0 || KB_KEYTYPE[sel_vec[j] + 128 * show_layer] == 1) && (KB_KEYCODE[sel_vec[j] + 128 * show_layer] >= 0x0100 && KB_KEYCODE[sel_vec[j] + 128 * show_layer] <= 0x1fff)) {
                                            for (const elem of layer_key) {
                                                if (elem.v == (KB_KEYCODE[sel_vec[j] + 128 * show_layer] & 0x00ff) &&
                                                    found == 0) {
                                                    found = 1;
                                                    if (elem.hasOwnProperty('t'))
                                                        line1 = elem.t;
                                                }
                                                if (found)
                                                    break;
                                            }
                                            for (const elem of speci_key) {
                                                if (elem.v == (KB_KEYCODE[sel_vec[j] + 128 * show_layer] & 0x00ff) &&
                                                    found == 0) {
                                                    found = 1;
                                                    if (elem.hasOwnProperty('t'))
                                                        line1 = elem.t;
                                                    if (elem.hasOwnProperty('t2'))
                                                        line2 = elem.t2;
                                                }
                                                if (found)
                                                    break;
                                            }
                                            for (const elem of basic_key) {
                                                if (elem.v == (KB_KEYCODE[sel_vec[j] + 128 * show_layer] & 0x00ff) &&
                                                    found == 0) {
                                                    found = 1;
                                                    if (elem.hasOwnProperty('t'))
                                                        line1 = elem.t;
                                                    if (elem.hasOwnProperty('t2'))
                                                        line2 = elem.t2;
                                                }
                                                if (found)
                                                    break;
                                            }
                                            for (const elem of advan_key) {
                                                if (elem.v == (KB_KEYCODE[sel_vec[j] + 128 * show_layer] & 0x00ff) &&
                                                    found == 0) {
                                                    found = 1;
                                                    if (elem.hasOwnProperty('t'))
                                                        line1 = elem.t;
                                                    if (elem.hasOwnProperty('t2'))
                                                        line2 = elem.t2;
                                                }
                                                if (found)
                                                    break;
                                            }
                                        }
                                        if (KB_KEYTYPE[sel_vec[j] + 128 * show_layer] == 2) {
                                            found = 0;
                                            for (const elem of layer_key) {
                                                if (elem.v == KB_SETTING[sel_vec[j] + 128 * show_layer] &&
                                                    found == 0) {
                                                    found = 1;
                                                    if (elem.hasOwnProperty('t'))
                                                        line3 = elem.t;
                                                }
                                                if (found)
                                                    break;
                                            }
                                            for (const elem of speci_key) {
                                                if (elem.v == KB_SETTING[sel_vec[j] + 128 * show_layer] &&
                                                    found == 0) {
                                                    found = 1;
                                                    if (elem.hasOwnProperty('t'))
                                                        line3 = elem.t;
                                                    if (elem.hasOwnProperty('t2'))
                                                        line4 = elem.t2;
                                                }
                                                if (found)
                                                    break;
                                            }
                                            for (const elem of basic_key) {
                                                if (elem.v == KB_SETTING[sel_vec[j] + 128 * show_layer] &&
                                                    found == 0) {
                                                    found = 1;
                                                    if (elem.hasOwnProperty('t'))
                                                        line3 = elem.t;
                                                    if (elem.hasOwnProperty('t2'))
                                                        line4 = elem.t2;
                                                }
                                                if (found)
                                                    break;
                                            }
                                            for (const elem of advan_key) {
                                                if (elem.v == KB_SETTING[sel_vec[j] + 128 * show_layer] &&
                                                    found == 0) {
                                                    found = 1;
                                                    if (elem.hasOwnProperty('t'))
                                                        line3 = elem.t;
                                                    if (elem.hasOwnProperty('t2'))
                                                        line4 = elem.t2;
                                                }
                                                if (found)
                                                    break;
                                            }
                                        }
                                        if (KB_KEYTYPE[sel_vec[j] + 128 * show_layer] == 1 || KB_KEYTYPE[sel_vec[j] + 128 * show_layer] == 0) {
                                            if (KB_KEYCODE[sel_vec[j] + 128 * show_layer] >= 0x0100 && KB_KEYCODE[sel_vec[j] + 128 * show_layer] <= 0x1fff) {
                                                parent_tooltips.disabled = false;
                                                parent_tooltips.querySelector('.tooltipslot').innerHTML = `<div>Modifier + ${line1}${line2}`;
                                                inner = `<div style="line-height: 1.4; font-size: ${font_size};">
                              <div style="width: 100%;">
                                  MOD
                              </div>
                              <div style="width: 100%;">
                                  ${line1}
                              </div>
                              <div style="width: 100%;">
                                  ${line2}
                              </div>
                          </div>`;
                                                if (j == 0)
                                                    socd_key_text_41 = `MOD ${line1} + ${line2}`;
                                                else
                                                    socd_key_text_42 = `MOD ${line1} + ${line2}`;
                                            }
                                            else
                                                inner = `<div style="line-height: 1.4; font-size: ${font_size};">
                              <div style="width: 100%;">
                                  ${line1}
                              </div>
                              <div style="width: 100%;">

                              </div>
                              <div style="width: 100%;">
                                  ${line2}
                              </div>
                          </div>`;
                                            if (j == 0)
                                                socd_key_text_41 = `${line1} ${line2}`;
                                            else
                                                socd_key_text_42 = `${line1} ${line2}`;
                                        }
                                        if (KB_KEYTYPE[sel_vec[j] + 128 * show_layer] == 0xf0) {
                                            inner = `<div style="line-height: 1.4; font-size: ${font_size};">
                            <div style="width: 100%;">
                                ${line1}
                            </div>
                            <div style="width: 100%;">

                            </div>
                            <div style="width: 100%;">
                                ${line2}
                            </div>
                        </div>`;
                                            if (j == 0)
                                                socd_key_text_41 = `${line1} ${line2}`;
                                            else
                                                socd_key_text_42 = `${line1} ${line2}`;
                                        }
                                        if (KB_KEYTYPE[sel_vec[j] + 128 * show_layer] == 2) {
                                            parent_tooltips.disabled = false;
                                            parent_tooltips.querySelector('.tooltipslot').innerHTML = `<div>Tap : ${line1}${line2}</div><div>Hold : ${line3}${line4}</div>`;
                                            inner = `<div style="line-height: 1.4; font-size: ${font_size};">
                            <div style="width: 100%;">
                                TAP
                            </div>
                            <div style="width: 100%;">
                                ${line1}
                            </div>
                            <div style="width: 100%;">
                                ${line3}
                            </div>
                        </div>`;
                                            if (j == 0)
                                                socd_key_text_41 = `TAP ${line1} ${line2}`;
                                            else
                                                socd_key_text_42 = `TAP ${line1} ${line2}`;
                                        }
                                        e.innerHTML = inner;
                                    }
                                    updateUI();
                                }
                            }
                            console.log(`Actuation Tab : ${sel_vec}`);
                            break;
                        default:
                    }
                    updateKB();
                });
                element.addEventListener('onmouseover', async function (event) {
                    element.parentElement.open = true;
                });
                element.addEventListener('onmouseout', async function (event) {
                    element.parentElement.open = false;
                });
            });
            return 0;
        }
        else {
            return 1;
        }
    }
    function isJsonString(str) {
        return typeof str === 'object';
    }
    async function createremap() {
        const basic_keyremap = document.getElementById('basic-keyremap');
        const advan_keyremap = document.getElementById('advan-keyremap');
        const speci_keyremap = document.getElementById('speci-keyremap');
        const layer_keyremap = document.getElementById('layer-keyremap');
        const skb_keyremap = document.getElementById('skb-keyremap');
        let key;
        basic_key.forEach(function (element, i) {
            key = document.createElement('div');
            if (element.hasOwnProperty('endl')) {
                key.setAttribute('style', 'width: 100%');
            }
            else {
                key.innerHTML = subcreateremap(element);
                key.className = 'btn-space';
            }
            basic_keyremap.append(key);
        });
        advan_key.forEach(function (element, i) {
            key = document.createElement('div');
            if (element.hasOwnProperty('endl')) {
                key.setAttribute('style', 'width: 100%');
            }
            else {
                if (element.hasOwnProperty('ver')) {
                    key.innerHTML = subcreateremap(element);
                    key.className = `${element.ver} btn-space`;
                }
                else {
                    key.innerHTML = subcreateremap(element);
                    key.className = 'btn-space';
                }
            }
            advan_keyremap.append(key);
        });
        speci_key.forEach(function (element, i) {
            key = document.createElement('div');
            if (element.hasOwnProperty('endl')) {
                key.setAttribute('style', 'width: 100%');
            }
            else {
                key.innerHTML = subcreateremap(element);
                key.className = 'btn-space';
            }
            speci_keyremap.append(key);
        });
        layer_key.forEach(function (element, i) {
            key = document.createElement('div');
            if (element.hasOwnProperty('endl')) {
                key.setAttribute('style', 'width: 100%');
            }
            else {
                key.innerHTML = subcreateremap(element);
                key.className = 'btn-space';
            }
            layer_keyremap.append(key);
        });
        skb_key.forEach(function (element, i) {
            key = document.createElement('div');
            if (element.hasOwnProperty('endl')) {
                key.setAttribute('style', 'width: 100%');
            }
            else {
                key.innerHTML = subcreateremap(element);
                key.className = 'btn-space';
            }
            skb_keyremap.append(key);
        });
        divRemap = document.getElementsByClassName('getRemap');
        Array.from(divRemap).forEach(function (element, i) {
            element.addEventListener('click', async function (event) {
                [...skb_key, ...layer_key, ...basic_key, ...advan_key, ...speci_key].forEach(function (elem, i) {
                    if (parseInt(element.dataset.value) == elem.v) {
                        console.log(parseInt(element.dataset.value));
                        is_sel.forEach(async function (value, i) {
                            if (is_sel[i] == 1) {
                                if (remap_mode == 2) {
                                    const key = parseInt(element.dataset.value);
                                    if (advTap_sel == 1)
                                        advTapval1 = key;
                                    if (advTap_sel == 2)
                                        advTapval2 = key;
                                    console.log(advTapval1, advTapval2);
                                    setkeycode(i, kb_layer, 2, advTapval1, advTapval2);
                                    advTap_sel = 0;
                                }
                                else {
                                    const key = parseInt(element.dataset.value);
                                    const key0 = parseInt(element.dataset.value0);
                                    const key2 = parseInt(element.dataset.value2);
                                    setkeycode(i, kb_layer, key0, key, key2);
                                    is_sel[i] = 0;
                                    remap_mode = 0;
                                }
                            }
                        });
                        updateKB();
                        updateUI();
                    }
                });
            });
        });
    }
    function subcreateremap(element) {
        let inner;
        let toprow = '';
        let botrow = '';
        let option_ver = '';
        let value0 = 1;
        let value2 = 0;
        if (element.hasOwnProperty('v')) {
            if (element.hasOwnProperty('t'))
                toprow = element.t;
            if (element.hasOwnProperty('t2'))
                botrow = element.t2;
            if (element.hasOwnProperty('v2'))
                value0 = element.v2;
            if (element.hasOwnProperty('v3'))
                value2 = element.v3;
            if (element.hasOwnProperty('ver'))
                option_ver = element.ver;
            if (element.hasOwnProperty('tp')) {
                inner = `<mdui-tooltip content="${element.tp}">
                    <mdui-button data-value="${element.v}" data-value0="${value0}" data-value2="${value2}" variant="tonal" class="key-100u getRemap" style="border-color: --mdui-color-primary-light!important; border-style: solid; border-width: 0px;">
                        <div style="line-height: 1.4; font-size: ${font_size};">
                            <div style="width: 100%;">
                                ${toprow}
                            </div>
                            <div style="width: 100%;">
                                ${botrow}
                            </div>
                            <div style="width: 100%;">
                                ${' '}
                            </div>
                        </div>
                    </mdui-button>
                </mdui-tooltip>`;
            }
            else {
                inner = `<mdui-button data-value="${element.v}" data-value0="${value0}" data-value2="${value2}" variant="tonal" class="key-100u getRemap" style="border-color: --mdui-color-primary-light!important; border-style: solid; border-width: 0px;">
                    <div style="line-height: 1.4; font-size: ${font_size};">
                        <div style="width: 100%;">
                            ${toprow}
                        </div>
                        <div style="width: 100%;">
                            ${botrow}
                        </div>
                        <div style="width: 100%;">
                            ${' '}
                        </div>
                    </div>
                </mdui-button>`;
            }
        }
        else {
            inner = `<mdui-button data-value="${element.v}" data-value0="${value0}" data-value2="${value2}" variant="tonal" class="key-100u getRemap" style="border-color: --mdui-color-primary-light!important; border-style: solid; border-width: 0px;">
                    <div style="line-height: 1.4; font-size: ${font_size};">
                        <div style="width: 100%;">
                            ${' '}
                        </div>
                        <div style="width: 100%;">
                            ${' '}
                        </div>
                        <div style="width: 100%;">
                            ${' '}
                        </div>
                    </div>
                </mdui-button>`;
        }
        return inner;
    }
    Array.from(advModKey).forEach(function (element, i) {
        element.addEventListener('click', async function (event) {
            if (i >= 0 && i < 8 && advmod_addr != -1) {
                let addr = advmod_addr + 128 * kb_layer;
                let keycode = KB_KEYCODE[addr];
                if (i >= 4) {
                    console.log(KB_KEYTYPE[addr], KB_KEYCODE[addr], KB_SETTING[addr]);
                    if ((keycode & 0x1000) == 0x0000)
                        keycode &= 0x00ff;
                    keycode = (((keycode & 0x0fff) | 0x1000) ^ (0x0100 << (i - 4)));
                    if ((keycode & 0x0f00) == 0)
                        keycode &= 0x00ff;
                    setkeycode(advmod_addr, kb_layer, KB_KEYTYPE[addr], keycode, 0);
                    console.log(KB_KEYTYPE[addr], KB_KEYCODE[addr], KB_SETTING[addr], keycode);
                }
                else if (i < 4) {
                    console.log(KB_KEYTYPE[addr], KB_KEYCODE[addr], KB_SETTING[addr]);
                    if ((keycode & 0x1000) == 0x1000)
                        keycode &= 0x00ff;
                    keycode = (((keycode & 0x0fff) | 0x0000) ^ (0x0100 << (i)));
                    setkeycode(advmod_addr, kb_layer, KB_KEYTYPE[addr], keycode, 0);
                    console.log(KB_KEYTYPE[addr], KB_KEYCODE[addr], KB_SETTING[addr], keycode);
                }
                updateKB();
                updateUI();
            }
        });
    });
    advMod.addEventListener('click', async function (event) {
        if (remap_mode == 1)
            remap_mode = 0;
        else
            remap_mode = 1;
        updateUI();
    });
    advTap.addEventListener('click', async function (event) {
        if (remap_mode == 2)
            remap_mode = 0;
        else {
            remap_mode = 2;
            advTap_sel = 0;
        }
        updateUI();
    });
    advTap1.addEventListener('click', async function (event) {
        if (advTap_sel == 1)
            advTap_sel = 0;
        else
            advTap_sel = 1;
        updateUI();
    });
    advTap2.addEventListener('click', async function (event) {
        if (advTap_sel == 2)
            advTap_sel = 0;
        else
            advTap_sel = 2;
        updateUI();
    });
    const connectButton = document.getElementById('connectButton');
    connectButton.addEventListener('click', async function (event) {
        fw_tar_build = "stable";
        SKBHID();
    });
    const connectfrommainpage = document.getElementById('connectfrommainpage');
    connectfrommainpage.addEventListener('click', async function (event) {
        fw_tar_build = "stable";
        SKBHID();
    });
    connectFWUpdate.addEventListener("click", async function (event) {
        SKBHID();
    });
    const Demobtn = document.getElementById('Demobtn');
    Demobtn.addEventListener('click', async function (event) {
        await createKeyboardjson(12545);
        remap_mode = 0;
        for (let i = 0; i < 128; ++i) {
            is_sel[i] = 0;
            ap_dis[i] = 30;
            rt_up[i] = 10;
            rt_dn[i] = 10;
            rt_mode[i] = 0;
            is_global[i] = 1;
            is_jade[i] = 0;
            raw_matrix[i] = 0;
            raw_matrix_mark[i] = 0;
            val_adc[i] = 4095;
            dist[i] = 0;
            rt_link[i] = 1;
            socd_key[i] = 0;
            socd_mode[i] = 0;
        }
        for (let i = 0; i < MAX_KB_LAYER * 128; ++i) {
            KB_KEYTYPE[i] = 0;
            KB_KEYCODE[i] = 0;
            KB_SETTING[i] = 0;
        }
        for (let i = 0; i < ADV_MAP * 16; ++i) {
            KB_ADV_MAP[i] = 0;
        }
        KB_KEYTYPE = new Uint16Array(default_KB_KEYTYPE);
        KB_KEYCODE = new Uint16Array(default_KB_KEYCODE);
        KB_SETTING = new Uint16Array(default_KB_SETTING);
        device_info.innerHTML = `${(await getTranslation("device_name") ?? "").replace("${}", "Demo")}`;
        for (let i = 0; i < 64; ++i) {
            serial_num[i] = 48;
        }
        serial_num_len = 0;
        fw_number = 32;
        option_ver();
        updateKB();
        await updateUI();
        tab_sel.value = '0';
        landpage.hidden = true;
        configurator.hidden = false;
    });
    const forgotdevice = document.getElementById('forgotdevice');
    forgotdevice.addEventListener('click', async function (event) {
        if (hidDevice) {
            if (hidDevice.opened) {
                hidDevice.forget();
            }
        }
        landpage.hidden = false;
        configurator.hidden = true;
    });
    const devices = await nv?.hid.getDevices();
    devices.forEach(async function (device) {
        if (device.collections[0].usagePage === 0xff53 &&
            device.collections[0].usage === 0x61) {
            hidDevice = device;
            if (!hidDevice.opened) {
                await hidDevice.open();
                console.log(device);
                await HIDFETCH();
            }
        }
    });
    nv?.hid.addEventListener('connect', async function (event) {
        if (event.device.collections[0].usagePage === 0xff53 &&
            event.device.collections[0].usage === 0x61) {
            hidDevice = event.device;
            if (!hidDevice.opened) {
                await hidDevice.open();
                console.log(event.device);
                if ((tab_sel.value == 'tab-5'))
                    tab_sel.value = 'tab-1';
                tab_sel_func();
                HIDFETCH();
            }
        }
    });
    nv?.hid.addEventListener('disconnect', (event) => {
        if (event.device.collections[0].usagePage === 0xff53 &&
            event.device.collections[0].usage === 0x61) {
            interval_halt = 1;
            enteriap.disabled = true;
            console.log(`HID disconnected: `, event.device.productName);
            console.log(event.device);
            popupdialog.open = false;
            hidDevice.close();
        }
    });
    async function SKBHID() {
        try {
            const filters = [
                { vendorId: 0x534b, usagePage: 0xff53, usage: 0x61 },
                { vendorId: 0x534b, usagePage: 0xff53, usage: 0x62 },
                { vendorId: 0x534b, productId: 0x1000 },
                { vendorId: 0x534b, productId: 0x1100 },
            ];
            hidList = await nv?.hid.requestDevice({ filters });
            if (!hidList)
                return;
            if (hidList.length <= 0)
                return;
            hidDevice = hidList[0];
            if (!hidDevice.opened) {
                await hidDevice.open();
                if (!hidDevice.opened) {
                    console.log('open failed');
                    return;
                }
            }
            console.log(hidDevice);
            HIDFETCH();
        }
        catch (error) {
            console.error('Failed to connect to HID device:', error);
        }
    }
    async function HIDFETCH() {
        if (hidDevice) {
            landpage.hidden = true;
            configurator.hidden = false;
            if (hidDevice.collections[0].usagePage == 0xff53 &&
                hidDevice.collections[0].usage == 0x62) {
                is_keyboard = 0;
                if (fw === null)
                    fw = new Firmware(hidDevice);
                else {
                    fw = null;
                    fw = new Firmware(hidDevice);
                }
                enteriap.disabled = true;
                connectFWUpdate.disabled = false;
                startupdate.disabled = false;
                exitiap.disabled = false;
                await checknewfw(hidDevice.productId);
                updateUI();
            }
            else if (hidDevice.productId == 0x3101) {
                kb_act_min = 2;
                is_keyboard = 1;
            }
            else if (hidDevice.productId == 0x3102) {
                kb_act_min = 4;
                is_keyboard = 1;
            }
            else if (hidDevice.productId == 0x3103) {
                kb_act_min = 2;
                is_keyboard = 1;
            }
            else if (hidDevice.productId == 0x3104) {
                kb_act_min = 2;
                is_keyboard = 1;
            }
            else if (hidDevice.productId == 0x3105) {
                kb_act_min = 2;
                is_keyboard = 1;
            }
            else if (hidDevice.productId == 0x3106) {
                kb_act_min = 2;
                is_keyboard = 1;
            }
            else if (hidDevice.productId == 0x3201) {
                kb_act_min = 2;
                is_keyboard = 1;
            }
            else if (hidDevice.productId == 0x3301) {
                kb_act_min = 2;
                is_keyboard = 1;
            }
            else if (hidDevice.productId == 0x3302) {
                kb_act_min = 2;
                is_keyboard = 1;
            }
            device_info.innerHTML = `${(await getTranslation("device_name") ?? "").replace("${}", `${hidDevice.productName}`)}`;
            console.log(`HID: \"${hidDevice.productId}\" \"${hidDevice.vendorId}\" \"${hidDevice.productName}\" `);
            myQueue = new HIDQueue(hidDevice);
            if (is_keyboard) {
                enteriap.disabled = false;
                connectFWUpdate.disabled = true;
                startupdate.disabled = true;
                exitiap.disabled = true;
                popupinner.innerHTML = `Loading Data`;
                popupdialog.open = true;
                remap_mode = 0;
                if ((tab_sel.value == 'tab-5'))
                    tab_sel.value = 'tab-1';
                tab_sel_func();
                for (let i = 0; i < 128; ++i) {
                    is_sel[i] = 0;
                    ap_dis[i] = 0;
                    rt_up[i] = 0;
                    rt_dn[i] = 0;
                    rt_mode[i] = 0;
                    is_global[i] = 1;
                    is_jade[i] = 0;
                    raw_matrix[i] = 0;
                    raw_matrix_mark[i] = 0;
                    val_adc[i] = 4095;
                    dist[i] = 0;
                    rt_link[i] = 1;
                    socd_key[i] = 0;
                    socd_mode[i] = 0;
                }
                for (let i = 0; i < MAX_KB_LAYER * 128; ++i) {
                    KB_KEYTYPE[i] = 0;
                    KB_KEYCODE[i] = 0;
                    KB_SETTING[i] = 0;
                }
                for (let i = 0; i < ADV_MAP * 16; ++i) {
                    KB_ADV_MAP[i] = 0;
                }
                resetSelKey();
                const a = await loadKeyboardSetting();
                await createKeyboardjson(hidDevice.productId);
                await checknewfw(hidDevice.productId);
                updateUI();
                updateKB();
                console.log(`curr fw ${fw_number}`);
                await option_ver();
                tab_sel.value = '0';
                popupdialog.open = false;
            }
            else {
                firmwaredialog.open = true;
            }
        }
    }
    async function option_ver() {
        console.log(`fw ${fw_number}`);
        if (fw_number < 15) {
            let option_ver_15 = document.getElementsByClassName("option-ver-15");
            for (const option of option_ver_15) {
                option.hidden = true;
            }
        }
        else {
            let option_ver_15 = document.getElementsByClassName("option-ver-15");
            for (const option of option_ver_15) {
                option.hidden = false;
            }
        }
        if (fw_number < 20) {
            let swSelect_list = document.getElementById("swSelect");
            swSelect_list.innerHTML = `<mdui-menu-item value="1" data-i18n="switch-01">${(await getTranslation("switch-01") ?? "")}</mdui-menu-item>
                                  <mdui-menu-item value="0" data-i18n="switch-00">${(await getTranslation("switch-00") ?? "")}</mdui-menu-item>`;
        }
        else {
            let swSelect_list = document.getElementById("swSelect");
            swSelect_list.innerHTML = `<mdui-menu-item value="3" data-i18n="switch-03">${(await getTranslation("switch-03") ?? "")}</mdui-menu-item>
                                  <mdui-menu-item value="2" data-i18n="switch-02">${(await getTranslation("switch-02") ?? "")}</mdui-menu-item>
                                  <mdui-menu-item value="1" data-i18n="switch-01">${(await getTranslation("switch-01") ?? "")}</mdui-menu-item>
                                  <mdui-menu-item value="0" data-i18n="switch-00">${(await getTranslation("switch-00") ?? "")}</mdui-menu-item>`;
        }
        if (fw_number < 30) {
            let option_ver_30 = document.getElementsByClassName("option-ver-30");
            for (const option of option_ver_30) {
                option.hidden = true;
            }
        }
        else {
            let option_ver_30 = document.getElementsByClassName("option-ver-30");
            for (const option of option_ver_30) {
                option.hidden = false;
            }
        }
        if (fw_number < 32) {
            let option_ver_32 = document.getElementsByClassName("option-ver-32");
            for (const option of option_ver_32) {
                option.hidden = true;
            }
        }
        else {
            let option_ver_32 = document.getElementsByClassName("option-ver-32");
            for (const option of option_ver_32) {
                option.hidden = false;
            }
        }
        if (fw_number < 36) {
            let option_ver_36 = document.getElementsByClassName("option-ver-36");
            console.log(option_ver_36);
            for (const option of option_ver_36) {
                option.setAttribute('style', 'display: none!important');
                option.hidden = true;
            }
        }
        else {
            let option_ver_36 = document.getElementsByClassName("option-ver-36");
            for (const option of option_ver_36) {
                option.setAttribute('style', 'display: inline-block');
                option.hidden = false;
            }
        }
    }
    async function SKBAPI(bytearr) {
        if (bytearr.length == 0)
            return;
        if (bytearr[0] == 0)
            return;
        switch (bytearr[0]) {
            case 0x85:
                fw.fwstatus = bytearr;
                break;
            case 48:
                if (bytearr[1] == 0x00) {
                    loadKBstop = 1;
                    await sleep(1000);
                    loadKBstop = 0;
                    await loadKeyboardSettingLite();
                    popupinner.innerHTML = `Loading Profile ${kb_profile}`;
                    popupdialog.open = true;
                    await loadKeyboardSetting();
                    updateKB();
                    updateUI();
                    popupdialog.open = false;
                }
                else if (bytearr[1] == 0x01) {
                    await sleep(10);
                    await loadKeyboardSettingLite();
                    updateUI();
                }
                break;
            case 64:
                kb_profile = bytearr[1];
                break;
            case 65:
                if (bytearr[2] != 0xff) {
                    for (let d = 0; d < 16; ++d) {
                        const m = d + bytearr[2] * 16 + bytearr[1] * 128;
                        if (m < 128 * MAX_KB_LAYER) {
                            KB_KEYTYPE[m] =
                                bytearr[d * 2 + 3] | ((bytearr[d * 2 + 4] & 0xff) << 8);
                        }
                    }
                }
                break;
            case 66:
                if (bytearr[2] != 0xff) {
                    for (let d = 0; d < 16; ++d) {
                        const m = d + bytearr[2] * 16 + bytearr[1] * 128;
                        if (m < 128 * MAX_KB_LAYER) {
                            KB_KEYCODE[m] =
                                bytearr[d * 2 + 3] | ((bytearr[d * 2 + 4] & 0xff) << 8);
                        }
                    }
                }
                break;
            case 67:
                if (bytearr[2] != 0xff) {
                    for (let d = 0; d < 16; ++d) {
                        const m = d + bytearr[2] * 16 + bytearr[1] * 128;
                        if (m < 128 * MAX_KB_LAYER) {
                            KB_SETTING[m] =
                                bytearr[d * 2 + 3] | ((bytearr[d * 2 + 4] & 0xff) << 8);
                        }
                    }
                }
                break;
            case 70:
                link_profile = bytearr[1];
                break;
            case 80:
                kb_profile = bytearr[1];
                break;
            case 95:
                if (bytearr[1] == 0x00) {
                    resetSelKey();
                    popupinner.innerHTML = `Reseting to Default`;
                    popupdialog.open = true;
                    await loadKeyboardSetting();
                    updateUI();
                    updateKB();
                    popupdialog.open = false;
                }
                break;
            case 144:
                if (bytearr[2] != 0xff) {
                    for (let d = 0; d < 16; ++d) {
                        ap_dis[d + bytearr[2] * 16] = bytearr[d * 2 + 3];
                    }
                }
                break;
            case 145:
                if (bytearr[2] != 0xff) {
                    for (let d = 0; d < 16; ++d) {
                        rt_up[d + bytearr[2] * 16] = bytearr[d * 2 + 3];
                    }
                }
                break;
            case 146:
                if (bytearr[2] != 0xff) {
                    for (let d = 0; d < 16; ++d) {
                        rt_dn[d + bytearr[2] * 16] = bytearr[d * 2 + 3];
                    }
                }
                break;
            case 147:
                if (bytearr[2] != 0xff) {
                    for (let d = 0; d < 16; ++d) {
                        rt_mode[d + bytearr[2] * 16] = bytearr[d * 2 + 3];
                    }
                }
                break;
            case 148:
                if (bytearr[2] != 0xff) {
                    for (let d = 0; d < 16; ++d) {
                        deadzone[d + bytearr[2] * 16] = bytearr[d * 2 + 3];
                    }
                }
                break;
            case 151:
                if (bytearr[2] != 0xff) {
                    for (let d = 0; d < 16; ++d) {
                        ap_dis_dual[d + bytearr[2] * 16] = bytearr[d * 2 + 3];
                    }
                }
                break;
            case 154:
                if (bytearr[2] != 0xff) {
                    for (let d = 0; d < 16; ++d) {
                        is_global[d + bytearr[2] * 16] = bytearr[d * 2 + 3];
                    }
                }
                break;
            case 155:
                if (bytearr[2] != 0xff) {
                    for (let d = 0; d < 16; ++d) {
                        rt_link[d + bytearr[2] * 16] = bytearr[d * 2 + 3];
                    }
                }
                break;
            case 156:
                if (bytearr[2] != 0xff) {
                    for (let d = 0; d < 16; ++d) {
                        socd_key[d + bytearr[2] * 16] = bytearr[d * 2 + 3];
                    }
                }
                break;
            case 157:
                if (bytearr[2] != 0xff) {
                    for (let d = 0; d < 16; ++d) {
                        socd_mode[d + bytearr[2] * 16] = bytearr[d * 2 + 3];
                    }
                }
                break;
            case 159:
                if (bytearr[2] != 0xff) {
                    for (let d = 0; d < 16; ++d) {
                        is_jade[d + bytearr[2] * 16] = bytearr[d * 2 + 3];
                    }
                }
                break;
            case 160:
                break;
            case 161:
                break;
            case 162:
                break;
            case 163:
                break;
            case 208:
                break;
            case 209:
                if (bytearr[2] != 0xff) {
                    for (let d = 0; d < 16; ++d) {
                        for (let b = 0; b < 8; ++b) {
                            if (raw_matrix[d * 8 + b] != (bytearr[d + 3] & (1 << b) ? 1 : 0) && (d * 8 + b) < 120) {
                                if ((bytearr[d + 3] & (1 << b) ? 1 : 0))
                                    console.log(`${d * 8 + b + 1} is press`);
                                else
                                    console.log(`${d * 8 + b + 1} is release`);
                            }
                            raw_matrix[d * 8 + b] = bytearr[d + 3] & (1 << b) ? 1 : 0;
                        }
                    }
                }
                break;
            case 210:
                if (bytearr[2] != 0xff) {
                    for (let d = 0; d < 16; ++d) {
                        val_adc[d + bytearr[2] * 16] =
                            bytearr[d * 2 + 3] | ((bytearr[d * 2 + 4] & 0xff) << 8);
                    }
                }
                break;
            case 211:
                if (bytearr[2] != 0xff) {
                    for (let d = 0; d < 16; ++d) {
                        dist[d + bytearr[2] * 16] = bytearr[d * 2 + 3];
                    }
                }
                break;
            case 213:
                auto_calibrate = bytearr[2];
                break;
            case 216:
                is_nkro = bytearr[2];
                break;
            case 217:
                if (kb_layout != bytearr[2]) {
                }
                kb_layout = bytearr[2];
                break;
            case 223:
                console.log(bytearr);
                break;
            case 224:
                if (bytearr[1] >= 0 && bytearr[1] <= 1) {
                    for (let d = 0; d < bytearr[2]; ++d) {
                        serial_num[d + bytearr[1] * 32] = bytearr[d + 4];
                    }
                    serial_num_len = bytearr[3];
                }
                break;
            case 226:
                if (bytearr[1] >= 0 && bytearr[1] <= 1) {
                    for (let d = 0; d < bytearr[2]; ++d) {
                        fw_version[d + bytearr[1] * 32] = bytearr[d + 4];
                    }
                    fw_version_len = bytearr[3];
                }
                break;
            case 227:
                fw_number = bytearr[1] | (bytearr[2] << 8);
                break;
            case 238:
                if (bytearr[1] == 0x01) {
                    resetSelKey();
                    popupinner.innerHTML = `Factory resetting`;
                    popupdialog.open = true;
                }
                else if (bytearr[1] == 0x00) {
                    popupdialog.open = false;
                }
                break;
            case 239:
                break;
            default:
                break;
        }
        await sleep(1);
        rx = bytearr[0];
    }
    async function sendDataTimeout(arr) {
        let command = new Uint8Array(arr);
        myQueue.enqueue(command);
        return 0;
    }
    async function setkeycode(index, layer, keytype, keycode, setting) {
        KB_KEYTYPE[layer * 128 + index] = keytype;
        KB_KEYCODE[layer * 128 + index] = keycode;
        KB_SETTING[layer * 128 + index] = setting;
        await sendDataTimeout([
            0x57,
            layer,
            keytype & 0xff,
            keytype >> 8,
            keycode & 0xff,
            keycode >> 8,
            setting & 0xff,
            setting >> 8,
            index,
        ]);
    }
    async function checkUsagePage() {
        try {
            if (hidDevice.opened)
                return (hidDevice.collections[0].usagePage == 0xff53 &&
                    hidDevice.collections[0].usage == 0x61);
            return false;
        }
        catch (e) {
            console.log(e);
            return false;
        }
    }
    async function loadKeyboardSetting() {
        loadKBstop = 0;
        let chk = 0;
        get_serial_number();
        get_firmware_version();
        get_auto_calibration();
        get_nkro_status();
        sendDataTimeout([217]);
        sendDataTimeout([64]);
        sendDataTimeout([70]);
        for (let i = 0; i < 8; ++i) {
            sendDataTimeout([144, 0, i]);
            sendDataTimeout([145, 0, i]);
            sendDataTimeout([146, 0, i]);
            sendDataTimeout([147, 0, i]);
            sendDataTimeout([148, 0, i]);
            sendDataTimeout([151, 0, i]);
            sendDataTimeout([154, 0, i]);
            sendDataTimeout([155, 0, i]);
            sendDataTimeout([156, 0, i]);
            sendDataTimeout([157, 0, i]);
            sendDataTimeout([159, 0, i]);
            for (let j = 0; j < MAX_KB_LAYER; ++j) {
                sendDataTimeout([65, j, i]);
                sendDataTimeout([66, j, i]);
                sendDataTimeout([67, j, i]);
            }
        }
        while (myQueue.isBusy()) {
            await sleep(1);
        }
        return chk;
    }
    async function loadKeyboardSettingLite() {
        let chk = 0;
        await get_auto_calibration();
        await get_nkro_status();
        await sendDataTimeout([64]);
        while (myQueue.isBusy()) {
            await sleep(1);
        }
        return chk;
    }
    async function getdebugvalue() {
        if (await checkUsagePage()) {
            for (let i = 0; i < 8; ++i) {
                if (interval_halt == 0) {
                    if (myQueue.isBusy() == 0) {
                        sendDataTimeout([210, 0, i]);
                        sendDataTimeout([211, 0, i]);
                        sendDataTimeout([209]);
                        await sleep(10);
                    }
                }
            }
            if (interval_halt == 0)
                updateKB();
        }
    }
    async function getrawmatrix() {
        if ((await checkUsagePage()) && raw_enable) {
            if (interval_halt == 0) {
                await sendDataTimeout([209]);
                await sleep(10);
                updateKB();
            }
        }
    }
    function resetSelKey() {
        for (let i = 0; i < 128; ++i)
            is_sel[i] = 0;
        sel_vec = [];
        updateKB();
    }
    function updateKB() {
        Array.from(divKey).forEach(function (element, i) {
            const parent_tooltips = element.parentElement;
            parent_tooltips.disabled = true;
            let inner = `<div style="line-height: 1.4; font-size: ${font_size};">
                    
                </div>`;
            switch (tab_selection) {
                case 0:
                case 12:
                    let line1 = '';
                    let line2 = '';
                    let line3 = '';
                    let line4 = '';
                    let found = 0;
                    element.setAttribute('variant', 'tonal');
                    let show_layer = kb_layer;
                    if (tab_selection == 12)
                        show_layer = 0;
                    for (const elem of skb_key) {
                        if (elem.v == KB_KEYCODE[element_mapping[i] + 128 * show_layer] &&
                            found == 0) {
                            if (elem.hasOwnProperty('v2')) {
                                if (elem.v2 == KB_KEYTYPE[element_mapping[i] + 128 * show_layer] &&
                                    found == 0) {
                                    found = 1;
                                    if (elem.hasOwnProperty('t'))
                                        line1 = elem.t;
                                    if (elem.hasOwnProperty('t2'))
                                        line2 = elem.t2;
                                }
                            }
                            else {
                                found = 1;
                                if (elem.hasOwnProperty('t'))
                                    line1 = elem.t;
                                if (elem.hasOwnProperty('t2'))
                                    line2 = elem.t2;
                            }
                        }
                        if (found)
                            break;
                    }
                    if (KB_KEYTYPE[element_mapping[i] + 128 * show_layer] == 0 || KB_KEYTYPE[element_mapping[i] + 128 * show_layer] == 1 || KB_KEYTYPE[element_mapping[i] + 128 * show_layer] == 2) {
                        for (const elem of layer_key) {
                            if (elem.v == KB_KEYCODE[element_mapping[i] + 128 * show_layer] &&
                                found == 0) {
                                found = 1;
                                if (elem.hasOwnProperty('t'))
                                    line1 = elem.t;
                            }
                            if (found)
                                break;
                        }
                        for (const elem of speci_key) {
                            if (elem.v == KB_KEYCODE[element_mapping[i] + 128 * show_layer] &&
                                found == 0) {
                                found = 1;
                                if (elem.hasOwnProperty('t'))
                                    line1 = elem.t;
                                if (elem.hasOwnProperty('t2'))
                                    line2 = elem.t2;
                            }
                            if (found)
                                break;
                        }
                        for (const elem of basic_key) {
                            if (elem.v == KB_KEYCODE[element_mapping[i] + 128 * show_layer] &&
                                found == 0) {
                                found = 1;
                                if (elem.hasOwnProperty('t'))
                                    line1 = elem.t;
                                if (elem.hasOwnProperty('t2'))
                                    line2 = elem.t2;
                            }
                            if (found)
                                break;
                        }
                        for (const elem of advan_key) {
                            if (elem.v == KB_KEYCODE[element_mapping[i] + 128 * show_layer] &&
                                found == 0) {
                                found = 1;
                                if (elem.hasOwnProperty('t'))
                                    line1 = elem.t;
                                if (elem.hasOwnProperty('t2'))
                                    line2 = elem.t2;
                            }
                            if (found)
                                break;
                        }
                    }
                    if ((KB_KEYTYPE[element_mapping[i] + 128 * show_layer] == 0 || KB_KEYTYPE[element_mapping[i] + 128 * show_layer] == 1) && (KB_KEYCODE[element_mapping[i] + 128 * show_layer] >= 0x0100 && KB_KEYCODE[element_mapping[i] + 128 * show_layer] <= 0x1fff)) {
                        for (const elem of layer_key) {
                            if (elem.v == (KB_KEYCODE[element_mapping[i] + 128 * show_layer] & 0x00ff) &&
                                found == 0) {
                                found = 1;
                                if (elem.hasOwnProperty('t'))
                                    line1 = elem.t;
                            }
                            if (found)
                                break;
                        }
                        for (const elem of speci_key) {
                            if (elem.v == (KB_KEYCODE[element_mapping[i] + 128 * show_layer] & 0x00ff) &&
                                found == 0) {
                                found = 1;
                                if (elem.hasOwnProperty('t'))
                                    line1 = elem.t;
                                if (elem.hasOwnProperty('t2'))
                                    line2 = elem.t2;
                            }
                            if (found)
                                break;
                        }
                        for (const elem of basic_key) {
                            if (elem.v == (KB_KEYCODE[element_mapping[i] + 128 * show_layer] & 0x00ff) &&
                                found == 0) {
                                found = 1;
                                if (elem.hasOwnProperty('t'))
                                    line1 = elem.t;
                                if (elem.hasOwnProperty('t2'))
                                    line2 = elem.t2;
                            }
                            if (found)
                                break;
                        }
                        for (const elem of advan_key) {
                            if (elem.v == (KB_KEYCODE[element_mapping[i] + 128 * show_layer] & 0x00ff) &&
                                found == 0) {
                                found = 1;
                                if (elem.hasOwnProperty('t'))
                                    line1 = elem.t;
                                if (elem.hasOwnProperty('t2'))
                                    line2 = elem.t2;
                            }
                            if (found)
                                break;
                        }
                    }
                    if (KB_KEYTYPE[element_mapping[i] + 128 * show_layer] == 2) {
                        found = 0;
                        for (const elem of layer_key) {
                            if (elem.v == KB_SETTING[element_mapping[i] + 128 * show_layer] &&
                                found == 0) {
                                found = 1;
                                if (elem.hasOwnProperty('t'))
                                    line3 = elem.t;
                            }
                            if (found)
                                break;
                        }
                        for (const elem of speci_key) {
                            if (elem.v == KB_SETTING[element_mapping[i] + 128 * show_layer] &&
                                found == 0) {
                                found = 1;
                                if (elem.hasOwnProperty('t'))
                                    line3 = elem.t;
                                if (elem.hasOwnProperty('t2'))
                                    line4 = elem.t2;
                            }
                            if (found)
                                break;
                        }
                        for (const elem of basic_key) {
                            if (elem.v == KB_SETTING[element_mapping[i] + 128 * show_layer] &&
                                found == 0) {
                                found = 1;
                                if (elem.hasOwnProperty('t'))
                                    line3 = elem.t;
                                if (elem.hasOwnProperty('t2'))
                                    line4 = elem.t2;
                            }
                            if (found)
                                break;
                        }
                        for (const elem of advan_key) {
                            if (elem.v == KB_SETTING[element_mapping[i] + 128 * show_layer] &&
                                found == 0) {
                                found = 1;
                                if (elem.hasOwnProperty('t'))
                                    line3 = elem.t;
                                if (elem.hasOwnProperty('t2'))
                                    line4 = elem.t2;
                            }
                            if (found)
                                break;
                        }
                    }
                    if (KB_KEYTYPE[element_mapping[i] + 128 * show_layer] == 1 || KB_KEYTYPE[element_mapping[i] + 128 * show_layer] == 0) {
                        if (KB_KEYCODE[element_mapping[i] + 128 * show_layer] >= 0x0100 && KB_KEYCODE[element_mapping[i] + 128 * show_layer] <= 0x1fff) {
                            parent_tooltips.disabled = false;
                            parent_tooltips.querySelector('.tooltipslot').innerHTML = `<div>Modifier + ${line1}${line2}`;
                            inner = `<div style="line-height: 1.4; font-size: ${font_size};">
                    <div style="width: 100%;">
                        MOD
                    </div>
                    <div style="width: 100%;">
                        ${line1}
                    </div>
                    <div style="width: 100%;">
                        ${line2}
                    </div>
                </div>`;
                        }
                        else
                            inner = `<div style="line-height: 1.4; font-size: ${font_size};">
                    <div style="width: 100%;">
                        ${line1}
                    </div>
                    <div style="width: 100%;">

                    </div>
                    <div style="width: 100%;">
                        ${line2}
                    </div>
                </div>`;
                    }
                    if (KB_KEYTYPE[element_mapping[i] + 128 * show_layer] == 0xf0) {
                        inner = `<div style="line-height: 1.4; font-size: ${font_size};">
                  <div style="width: 100%;">
                      ${line1}
                  </div>
                  <div style="width: 100%;">

                  </div>
                  <div style="width: 100%;">
                      ${line2}
                  </div>
              </div>`;
                    }
                    if (KB_KEYTYPE[element_mapping[i] + 128 * show_layer] == 2) {
                        parent_tooltips.disabled = false;
                        parent_tooltips.querySelector('.tooltipslot').innerHTML = `<div>Tap : ${line1}${line2}</div><div>Hold : ${line3}${line4}</div>`;
                        inner = `<div style="line-height: 1.4; font-size: ${font_size};">
                  <div style="width: 100%;">
                      TAP
                  </div>
                  <div style="width: 100%;">
                      ${line1}
                  </div>
                  <div style="width: 100%;">
                      ${line3}
                  </div>
              </div>`;
                    }
                    if (KB_KEYTYPE[element_mapping[i] + 128 * show_layer] == 0x03 && KB_KEYCODE[element_mapping[i] + 128 * show_layer] == 0x29 && KB_SETTING[element_mapping[i] + 128 * show_layer] == 0x35) {
                        parent_tooltips.disabled = false;
                        parent_tooltips.querySelector('.tooltipslot').innerHTML = `Esc when hold nothing, \` when hold GUI, ~ when hold shift`;
                        inner = `<div style="line-height: 1.4; font-size: ${font_size};">
                  <div style="width: 100%;">
                      Esc
                  </div>
                  <div style="width: 100%;">

                  </div>
                  <div style="width: 100%;">
                      \`
                  </div>
              </div>`;
                    }
                    if (tab_selection == 0) {
                        if (is_sel[element_mapping[i]] == 1) {
                            element.setAttribute('style', 'border-color: rgb(var(--mdui-color-primary))!important; border-style: solid; border-width: 3px;');
                        }
                        else {
                            element.setAttribute('style', 'border-color: rgb(var(--mdui-color-outline-variant))!important; border-style: solid; border-width: 0.0625rem;');
                        }
                    }
                    if (tab_selection == 12) {
                        if (socd_mode[element_mapping[i]] == 0 && socd_mode[socd_key[element_mapping[i]]] == 0) {
                        }
                        else {
                            let toolstip = "";
                            switch (socd_mode[element_mapping[i]] & 0x3f) {
                                case 1:
                                    toolstip = "Advanced SOCD";
                                    break;
                                case 2:
                                    toolstip = "SOCD";
                                    break;
                                case 3:
                                    toolstip = "Neutral";
                                    break;
                                case 4:
                                    toolstip = "High Priority";
                                    break;
                                case 5:
                                    toolstip = "Low Priority";
                                    break;
                                default:
                            }
                            if ((socd_mode[element_mapping[i]] & 0xc0) == 0xc0)
                                toolstip += " + Fully press";
                            if (socd_mode[element_mapping[i]] != 0) {
                                parent_tooltips.disabled = false;
                                parent_tooltips.querySelector('.tooltipslot').innerHTML = `<div>${toolstip}</div>`;
                            }
                        }
                        let style_elem = "";
                        if (is_sel[element_mapping[i]] == 1)
                            style_elem += "border-color: rgb(var(--mdui-color-primary))!important; border-style: solid; border-width: 3px; ";
                        else
                            style_elem += "border-color: rgb(var(--mdui-color-outline-variant))!important; border-style: solid; border-width: 0.0625rem; ";
                        switch (socd_mode[element_mapping[i]] & 0x3f) {
                            case 1:
                                style_elem += "color: rgb(var(--mdui-color-on-secondary-container-dark)); background-color: rgb(var(--mdui-color-socd01)); ";
                                break;
                            case 2:
                                style_elem += "color: rgb(var(--mdui-color-on-secondary-container-dark)); background-color: rgb(var(--mdui-color-socd02)); ";
                                break;
                            case 3:
                                style_elem += "color: rgb(var(--mdui-color-on-secondary-container-dark)); background-color: rgb(var(--mdui-color-socd03)); ";
                                break;
                            case 4:
                                style_elem += "color: rgb(var(--mdui-color-on-secondary-container-dark)); background-color: rgb(var(--mdui-color-socd04)); ";
                                break;
                            case 5:
                                style_elem += "color: rgb(var(--mdui-color-on-secondary-container-dark)); background-color: rgb(var(--mdui-color-socd05)); ";
                                break;
                        }
                        element.setAttribute('style', style_elem);
                    }
                    break;
                case 1:
                    parent_tooltips.disabled = false;
                    element.setAttribute('variant', 'tonal');
                    if (toggle_keybind == 0) {
                        if (is_global[element_mapping[i]] == 0) {
                            const t1 = `${(ap_dis[element_mapping[i]] / kb_act_div).toFixed(2)}`;
                            const t2 = `${(rt_up[element_mapping[i]] / kb_act_div).toFixed(2)}`;
                            const t3 = `${(rt_dn[element_mapping[i]] / kb_act_div).toFixed(2)}`;
                            if (rt_mode[element_mapping[i]] == 0) {
                                inner = `<div style="line-height: 1.4; font-size: ${font_size};">
                                      <div style="width: 100%;">
                                          ${t1}
                                      </div>
                                      <div style="width: 100%;">
                                          ${' '}
                                      </div>
                                      <div style="width: 100%;">
                                          ${' '}
                                      </div>
                                  </div>`;
                            }
                            else if (rt_mode[element_mapping[i]] == 1) {
                                inner = `<div style="line-height: 1.4; font-size: ${font_size};">
                                      <div style="width: 100%;">
                                          ${t1}
                                      </div>
                                      <div style="width: 100%;">
                                          ${t2}
                                      </div>
                                      <div style="width: 100%;">
                                          ${t3}
                                      </div>
                                  </div>`;
                            }
                            else if (rt_mode[element_mapping[i]] == 2) {
                                inner = `<div style="line-height: 1.4; font-size: ${font_size};">
                                      <div style="width: 100%;">
                                          ${t1}
                                      </div>
                                      <div style="width: 100%;">
                                          ${t2}C
                                      </div>
                                      <div style="width: 100%;">
                                          ${t3}C
                                      </div>
                                  </div>`;
                            }
                        }
                        else {
                            const t1 = `${(ap_dis[127] / kb_act_div).toFixed(2)}`;
                            const t2 = `${(rt_up[127] / kb_act_div).toFixed(2)}`;
                            const t3 = `${(rt_dn[127] / kb_act_div).toFixed(2)}`;
                            parent_tooltips.disabled = false;
                            if (rt_mode[127] == 0) {
                                inner = `<div style="line-height: 1.4; font-size: ${font_size};">
                                      <div style="width: 100%;">
                                          ${t1}
                                      </div>
                                      <div style="width: 100%;">
                                          ${' '}
                                      </div>
                                      <div style="width: 100%;">
                                          ${' '}
                                      </div>
                                  </div>`;
                            }
                            else if (rt_mode[127] == 1) {
                                inner = `<div style="line-height: 1.4; font-size: ${font_size};">
                                      <div style="width: 100%;">
                                          ${t1}
                                      </div>
                                      <div style="width: 100%;">
                                          ${t2}
                                      </div>
                                      <div style="width: 100%;">
                                          ${t3}
                                      </div>
                                  </div>`;
                            }
                            else if (rt_mode[127] == 2) {
                                inner = `<div style="line-height: 1.4; font-size: ${font_size};">
                                      <div style="width: 100%;">
                                          ${t1}
                                      </div>
                                      <div style="width: 100%;">
                                          ${t2}C
                                      </div>
                                      <div style="width: 100%;">
                                          ${t3}C
                                      </div>
                                  </div>`;
                            }
                        }
                    }
                    else {
                        let line1 = '';
                        let line2 = '';
                        let line3 = '';
                        let line4 = '';
                        let found = 0;
                        element.setAttribute('variant', 'tonal');
                        let show_layer = 0;
                        for (const elem of skb_key) {
                            if (elem.v == KB_KEYCODE[element_mapping[i] + 128 * show_layer] &&
                                found == 0) {
                                if (elem.hasOwnProperty('v2')) {
                                    if (elem.v2 == KB_KEYTYPE[element_mapping[i] + 128 * show_layer] &&
                                        found == 0) {
                                        found = 1;
                                        if (elem.hasOwnProperty('t'))
                                            line1 = elem.t;
                                        if (elem.hasOwnProperty('t2'))
                                            line2 = elem.t2;
                                    }
                                }
                                else {
                                    found = 1;
                                    if (elem.hasOwnProperty('t'))
                                        line1 = elem.t;
                                    if (elem.hasOwnProperty('t2'))
                                        line2 = elem.t2;
                                }
                            }
                            if (found)
                                break;
                        }
                        if (KB_KEYTYPE[element_mapping[i] + 128 * show_layer] == 0 || KB_KEYTYPE[element_mapping[i] + 128 * show_layer] == 1 || KB_KEYTYPE[element_mapping[i] + 128 * show_layer] == 2) {
                            for (const elem of layer_key) {
                                if (elem.v == KB_KEYCODE[element_mapping[i] + 128 * show_layer] &&
                                    found == 0) {
                                    found = 1;
                                    if (elem.hasOwnProperty('t'))
                                        line1 = elem.t;
                                }
                                if (found)
                                    break;
                            }
                            for (const elem of speci_key) {
                                if (elem.v == KB_KEYCODE[element_mapping[i] + 128 * show_layer] &&
                                    found == 0) {
                                    found = 1;
                                    if (elem.hasOwnProperty('t'))
                                        line1 = elem.t;
                                    if (elem.hasOwnProperty('t2'))
                                        line2 = elem.t2;
                                }
                                if (found)
                                    break;
                            }
                            for (const elem of basic_key) {
                                if (elem.v == KB_KEYCODE[element_mapping[i] + 128 * show_layer] &&
                                    found == 0) {
                                    found = 1;
                                    if (elem.hasOwnProperty('t'))
                                        line1 = elem.t;
                                    if (elem.hasOwnProperty('t2'))
                                        line2 = elem.t2;
                                }
                                if (found)
                                    break;
                            }
                            for (const elem of advan_key) {
                                if (elem.v == KB_KEYCODE[element_mapping[i] + 128 * show_layer] &&
                                    found == 0) {
                                    found = 1;
                                    if (elem.hasOwnProperty('t'))
                                        line1 = elem.t;
                                    if (elem.hasOwnProperty('t2'))
                                        line2 = elem.t2;
                                }
                                if (found)
                                    break;
                            }
                        }
                        if ((KB_KEYTYPE[element_mapping[i] + 128 * show_layer] == 0 || KB_KEYTYPE[element_mapping[i] + 128 * show_layer] == 1) && (KB_KEYCODE[element_mapping[i] + 128 * show_layer] >= 0x0100 && KB_KEYCODE[element_mapping[i] + 128 * show_layer] <= 0x1fff)) {
                            for (const elem of layer_key) {
                                if (elem.v == (KB_KEYCODE[element_mapping[i] + 128 * show_layer] & 0x00ff) &&
                                    found == 0) {
                                    found = 1;
                                    if (elem.hasOwnProperty('t'))
                                        line1 = elem.t;
                                }
                                if (found)
                                    break;
                            }
                            for (const elem of speci_key) {
                                if (elem.v == (KB_KEYCODE[element_mapping[i] + 128 * show_layer] & 0x00ff) &&
                                    found == 0) {
                                    found = 1;
                                    if (elem.hasOwnProperty('t'))
                                        line1 = elem.t;
                                    if (elem.hasOwnProperty('t2'))
                                        line2 = elem.t2;
                                }
                                if (found)
                                    break;
                            }
                            for (const elem of basic_key) {
                                if (elem.v == (KB_KEYCODE[element_mapping[i] + 128 * show_layer] & 0x00ff) &&
                                    found == 0) {
                                    found = 1;
                                    if (elem.hasOwnProperty('t'))
                                        line1 = elem.t;
                                    if (elem.hasOwnProperty('t2'))
                                        line2 = elem.t2;
                                }
                                if (found)
                                    break;
                            }
                            for (const elem of advan_key) {
                                if (elem.v == (KB_KEYCODE[element_mapping[i] + 128 * show_layer] & 0x00ff) &&
                                    found == 0) {
                                    found = 1;
                                    if (elem.hasOwnProperty('t'))
                                        line1 = elem.t;
                                    if (elem.hasOwnProperty('t2'))
                                        line2 = elem.t2;
                                }
                                if (found)
                                    break;
                            }
                        }
                        if (KB_KEYTYPE[element_mapping[i] + 128 * show_layer] == 2) {
                            found = 0;
                            for (const elem of layer_key) {
                                if (elem.v == KB_SETTING[element_mapping[i] + 128 * show_layer] &&
                                    found == 0) {
                                    found = 1;
                                    if (elem.hasOwnProperty('t'))
                                        line3 = elem.t;
                                }
                                if (found)
                                    break;
                            }
                            for (const elem of speci_key) {
                                if (elem.v == KB_SETTING[element_mapping[i] + 128 * show_layer] &&
                                    found == 0) {
                                    found = 1;
                                    if (elem.hasOwnProperty('t'))
                                        line3 = elem.t;
                                    if (elem.hasOwnProperty('t2'))
                                        line4 = elem.t2;
                                }
                                if (found)
                                    break;
                            }
                            for (const elem of basic_key) {
                                if (elem.v == KB_SETTING[element_mapping[i] + 128 * show_layer] &&
                                    found == 0) {
                                    found = 1;
                                    if (elem.hasOwnProperty('t'))
                                        line3 = elem.t;
                                    if (elem.hasOwnProperty('t2'))
                                        line4 = elem.t2;
                                }
                                if (found)
                                    break;
                            }
                            for (const elem of advan_key) {
                                if (elem.v == KB_SETTING[element_mapping[i] + 128 * show_layer] &&
                                    found == 0) {
                                    found = 1;
                                    if (elem.hasOwnProperty('t'))
                                        line3 = elem.t;
                                    if (elem.hasOwnProperty('t2'))
                                        line4 = elem.t2;
                                }
                                if (found)
                                    break;
                            }
                        }
                        if (KB_KEYTYPE[element_mapping[i] + 128 * show_layer] == 1 || KB_KEYTYPE[element_mapping[i] + 128 * show_layer] == 0) {
                            if (KB_KEYCODE[element_mapping[i] + 128 * show_layer] >= 0x0100 && KB_KEYCODE[element_mapping[i] + 128 * show_layer] <= 0x1fff) {
                                parent_tooltips.disabled = false;
                                parent_tooltips.querySelector('.tooltipslot').innerHTML = `<div>Modifier + ${line1}${line2}`;
                                inner = `<div style="line-height: 1.4; font-size: ${font_size};">
                      <div style="width: 100%;">
                          MOD
                      </div>
                      <div style="width: 100%;">
                          ${line1}
                      </div>
                      <div style="width: 100%;">
                          ${line2}
                      </div>
                  </div>`;
                            }
                            else
                                inner = `<div style="line-height: 1.4; font-size: ${font_size};">
                      <div style="width: 100%;">
                          ${line1}
                      </div>
                      <div style="width: 100%;">

                      </div>
                      <div style="width: 100%;">
                          ${line2}
                      </div>
                  </div>`;
                        }
                        if (KB_KEYTYPE[element_mapping[i] + 128 * show_layer] == 0xf0) {
                            inner = `<div style="line-height: 1.4; font-size: ${font_size};">
                    <div style="width: 100%;">
                        ${line1}
                    </div>
                    <div style="width: 100%;">

                    </div>
                    <div style="width: 100%;">
                        ${line2}
                    </div>
                </div>`;
                        }
                        if (KB_KEYTYPE[element_mapping[i] + 128 * show_layer] == 2) {
                            parent_tooltips.disabled = false;
                            parent_tooltips.querySelector('.tooltipslot').innerHTML = `<div>Tap : ${line1}${line2}</div><div>Hold : ${line3}${line4}</div>`;
                            inner = `<div style="line-height: 1.4; font-size: ${font_size};">
                    <div style="width: 100%;">
                        TAP
                    </div>
                    <div style="width: 100%;">
                        ${line1}
                    </div>
                    <div style="width: 100%;">
                        ${line3}
                    </div>
                </div>`;
                        }
                    }
                    if (is_global[element_mapping[i]] == 0) {
                        const t1 = `${(ap_dis[element_mapping[i]] / kb_act_div).toFixed(2)}`;
                        const t2 = `${(rt_up[element_mapping[i]] / kb_act_div).toFixed(2)}`;
                        const t3 = `${(rt_dn[element_mapping[i]] / kb_act_div).toFixed(2)}`;
                        if (rt_mode[element_mapping[i]] == 0) {
                            parent_tooltips.querySelector('.tooltipslot').innerHTML = `<div>Actuation : ${t1} mm</div>`;
                        }
                        else if (rt_mode[element_mapping[i]] == 1) {
                            parent_tooltips.querySelector('.tooltipslot').innerHTML =
                                `<div>Actuation : ${t1} mm</div><div>UpStroke : ${t2} mm</div><div>DownStroke : ${t3} mm</div>`;
                        }
                        else if (rt_mode[element_mapping[i]] == 2) {
                            parent_tooltips.querySelector('.tooltipslot').innerHTML =
                                `<div>Actuation : ${t1} mm</div><div>UpStroke : ${t2} mm</div><div>DownStroke : ${t3} mm</div><div>Continuous Rapid Trigger</div>`;
                        }
                    }
                    else {
                        const t1 = `${(ap_dis[127] / kb_act_div).toFixed(2)}`;
                        const t2 = `${(rt_up[127] / kb_act_div).toFixed(2)}`;
                        const t3 = `${(rt_dn[127] / kb_act_div).toFixed(2)}`;
                        parent_tooltips.disabled = false;
                        if (rt_mode[127] == 0) {
                            parent_tooltips.querySelector('.tooltipslot').innerHTML = `<div>Actuation : ${t1} mm</div>`;
                        }
                        else if (rt_mode[127] == 1) {
                            parent_tooltips.querySelector('.tooltipslot').innerHTML =
                                `<div>Actuation : ${t1} mm</div><div>UpStroke : ${t2} mm</div><div>DownStroke : ${t3} mm</div>`;
                        }
                        else if (rt_mode[127] == 2) {
                            parent_tooltips.querySelector('.tooltipslot').innerHTML =
                                `<div>Actuation : ${t1} mm</div><div>UpStroke : ${t2} mm</div><div>DownStroke : ${t3} mm</div><div>Continuous Rapid Trigger</div>`;
                        }
                    }
                    if (is_sel[element_mapping[i]] == 1) {
                        if (is_global[element_mapping[i]] == 0)
                            element.setAttribute('style', 'color: rgb(var(--mdui-color-on-secondary-container)); background-color: rgb(var(--mdui-color-tertiary-container));border-color: rgb(var(--mdui-color-primary))!important; border-style: solid; border-width: 3px;');
                        else
                            element.setAttribute('style', 'border-color: rgb(var(--mdui-color-primary))!important; border-style: solid; border-width: 3px;');
                    }
                    else {
                        if (is_global[element_mapping[i]] == 0)
                            element.setAttribute('style', 'color: rgb(var(--mdui-color-on-secondary-container)); background-color: rgb(var(--mdui-color-tertiary-container)); border-color: rgb(var(--mdui-color-outline-variant))!important; border-style: solid; border-width: 0.0625rem;');
                        else
                            element.setAttribute('style', 'border-color: rgb(var(--mdui-color-outline-variant))!important; border-style: solid; border-width: 0.0625rem;');
                    }
                    break;
                case 2:
                    if (raw_matrix[element_mapping[i]]) {
                        raw_matrix_mark[element_mapping[i]] = 1;
                        element.setAttribute('variant', 'filled');
                        element.setAttribute('style', '');
                    }
                    else if (raw_matrix_mark[element_mapping[i]]) {
                        element.setAttribute('variant', 'tonal');
                        element.setAttribute('style', 'border-color: rgb(var(--mdui-color-outline-variant))!important; border-style: solid; border-width: 0.0625rem;');
                    }
                    else {
                        element.setAttribute('variant', 'outlined');
                        element.setAttribute('style', 'border-color: rgb(var(--mdui-color-outline-variant))!important; border-style: solid; border-width: 0.0625rem;');
                    }
                case 3:
                    break;
                case 4:
                    if (raw_matrix[element_mapping[i]]) {
                        raw_matrix_mark[element_mapping[i]] = 1;
                        element.setAttribute('variant', 'filled');
                        element.setAttribute('style', 'border-color: rgb(var(--mdui-color-outline-variant))!important; border-style: solid; border-width: 0.0625rem; color: #ffffff!important;');
                    }
                    else {
                        element.setAttribute('variant', 'outlined');
                        element.setAttribute('style', 'border-color: rgb(var(--mdui-color-outline-variant))!important; border-style: solid; border-width: 0.0625rem; color: rgb(var(--mdui-color-on-secondary-container));');
                    }
                    inner = `<div style="line-height: 1.4; font-size: ${font_size};">
                            <div style="width: 100%;">
                              ${val_adc[element_mapping[i]]}
                            </div>
                            <div style="width: 100%;">
                                ${' '}
                            </div>
                            <div style="width: 100%;">
                                ${(dist[element_mapping[i]] / kb_act_div).toFixed(2)}
                            </div>
                        </div>`;
                    break;
            }
            element.innerHTML = inner;
        });
    }
    async function updateUI() {
        serial_info.innerHTML = `${(await getTranslation("serial_number") ?? "").replace("${}", `${new TextDecoder().decode(serial_num.slice(0, serial_num_len))}`)}`;
        let cnt = 0;
        let cnt_global = 0;
        let has_global = 0;
        is_sel.forEach(async function (value, i) {
            if (is_sel[i] == 1) {
                advmod_addr = i;
                cnt++;
                if (is_global[i] == 0)
                    cnt_global++;
            }
            if (is_global[i] == 0)
                has_global = 1;
        });
        is_default_slider = 0;
        if (cnt == 0)
            is_default_slider = 1;
        if (cnt == 0) {
            advMod.disabled = true;
            advTap.disabled = true;
            divMod.hidden = true;
            divTap.hidden = true;
            Array.from(advModKey).forEach(function (element, i) {
                element.setAttribute('style', 'border-color: rgb(var(--mdui-color-outline-variant))!important; border-style: solid; border-width: 0.0625rem;');
            });
        }
        if (cnt == 1 && advmod_addr != -1) {
            Array.from(advModKey).forEach(function (element, i) {
                let addr = advmod_addr + 128 * kb_layer;
                if ((KB_KEYTYPE[addr] == 1 || KB_KEYTYPE[addr] == 0) && (KB_KEYCODE[addr] >= 0x0000 && KB_KEYCODE[addr] <= 0x1fff)) {
                    if (i >= 4 && (KB_KEYCODE[addr] & 0x1000) == 0x1000 && ((KB_KEYCODE[addr] & (0x0100 << (i - 4))) == (0x0100 << (i - 4)))) {
                        element.setAttribute('style', 'border-color: rgb(var(--mdui-color-primary))!important; border-style: solid; border-width: 3px;');
                    }
                    else if (i < 4 && (KB_KEYCODE[addr] & 0x1000) == 0x0000 && ((KB_KEYCODE[addr] & (0x0100 << i)) == (0x0100 << i))) {
                        element.setAttribute('style', 'border-color: rgb(var(--mdui-color-primary))!important; border-style: solid; border-width: 3px;');
                    }
                    else {
                        element.setAttribute('style', 'border-color: rgb(var(--mdui-color-outline-variant))!important; border-style: solid; border-width: 0.0625rem;');
                    }
                }
            });
        }
        advMod.setAttribute('style', 'border-color: rgb(var(--mdui-color-outline-variant))!important; border-style: solid; border-width: 0.0625rem;');
        advTap.setAttribute('style', 'border-color: rgb(var(--mdui-color-outline-variant))!important; border-style: solid; border-width: 0.0625rem;');
        skb_setting_div.hidden = false;
        switch (remap_mode) {
            case 0:
                divMod.hidden = true;
                divTap.hidden = true;
                advTap_sel = 0;
                break;
            case 1:
                divMod.hidden = false;
                divTap.hidden = true;
                advMod.setAttribute('style', 'border-color: rgb(var(--mdui-color-primary))!important; border-style: solid; border-width: 3px;');
                break;
            case 2:
                divMod.hidden = true;
                divTap.hidden = false;
                skb_setting_div.hidden = true;
                advTap.setAttribute('style', 'border-color: rgb(var(--mdui-color-primary))!important; border-style: solid; border-width: 3px;');
                break;
        }
        advTap1.setAttribute('style', 'border-color: rgb(var(--mdui-color-outline-variant))!important; border-style: solid; border-width: 0.0625rem;');
        advTap2.setAttribute('style', 'border-color: rgb(var(--mdui-color-outline-variant))!important; border-style: solid; border-width: 0.0625rem;');
        switch (advTap_sel) {
            case 0:
                break;
            case 1:
                advTap1.setAttribute('style', 'border-color: rgb(var(--mdui-color-primary))!important; border-style: solid; border-width: 3px;');
                break;
            case 2:
                advTap2.setAttribute('style', 'border-color: rgb(var(--mdui-color-primary))!important; border-style: solid; border-width: 3px;');
                break;
        }
        updateUITap(advTap1, advTapval1);
        updateUITap(advTap2, advTapval2);
        swSelect.value = is_jade[127].toString();
        switch (is_jade[127]) {
            case 3:
                curr_switch.innerHTML = `${(await getTranslation("current_sw_display") ?? "").replace("${}", (await getTranslation("switch-03") ?? ""))}`;
                actuationSlider.max = 66 + 2;
                rtUpSlider.max = 66 + 2;
                rtDnSlider.max = 66 + 2;
                break;
            case 2:
                curr_switch.innerHTML = `${(await getTranslation("current_sw_display") ?? "").replace("${}", (await getTranslation("switch-02") ?? ""))}`;
                actuationSlider.max = 78 + 2;
                rtUpSlider.max = 78 + 2;
                rtDnSlider.max = 78 + 2;
                break;
            case 1:
                curr_switch.innerHTML = `${(await getTranslation("current_sw_display") ?? "").replace("${}", (await getTranslation("switch-01") ?? ""))}`;
                actuationSlider.max = 68 + 2;
                rtUpSlider.max = 68 + 2;
                rtDnSlider.max = 68 + 2;
                break;
            case 0:
            default:
                curr_switch.innerHTML = `${(await getTranslation("current_sw_display") ?? "").replace("${}", (await getTranslation("switch-00") ?? ""))}`;
                actuationSlider.max = 80 + 2;
                rtUpSlider.max = 80 + 2;
                rtDnSlider.max = 80 + 2;
                break;
        }
        deadzoneSlider.value = deadzone[127];
        let swdist = sw_dist(is_jade[127]);
        deadzoneValue.innerHTML = `${(await getTranslation("deadzone_display_global") ?? "").replace("${}", `${(deadzoneSlider.value / kb_act_div).toFixed(2)}`)}`;
        if (is_default_slider) {
            actuationSlider.value = ap_dis[127];
            rtUpSlider.value = rt_up[127];
            rtDnSlider.value = rt_dn[127];
            actValue.innerHTML = `${(await getTranslation("actuation_display_global") ?? "").replace("${}", `${(actuationSlider.value / kb_act_div).toFixed(2)}`)}`;
            rtUpValue.innerHTML = `${(await getTranslation("rt_up_display_global") ?? "").replace("${}", `${(rtUpSlider.value / kb_act_div).toFixed(2)}`)}`;
            rtDnValue.innerHTML = `${(await getTranslation("rt_down_display_global") ?? "").replace("${}", `${(rtDnSlider.value / kb_act_div).toFixed(2)}`)}`;
            if (rt_mode[127] == 0) {
                RTSw.checked = false;
                RTConn.checked = false;
            }
            else {
                RTSw.checked = true;
                RTConn.checked = false;
                if (rt_mode[127] == 2) {
                    RTConn.checked = true;
                }
            }
            deselectedAll.disabled = true;
        }
        else {
            while (is_sel[sel_vec[0]] == 0)
                sel_vec.splice(0, 1);
            actuationSlider.value = ap_dis[sel_vec[0]];
            rtUpSlider.value = rt_up[sel_vec[0]];
            rtDnSlider.value = rt_dn[sel_vec[0]];
            actValue.innerHTML = `${(await getTranslation("actuation_display") ?? "").replace("${}", `${(actuationSlider.value / kb_act_div).toFixed(2)}`)}`;
            rtUpValue.innerHTML = `${(await getTranslation("rt_up_display") ?? "").replace("${}", `${(rtUpSlider.value / kb_act_div).toFixed(2)}`)}`;
            rtDnValue.innerHTML = `${(await getTranslation("rt_down_display") ?? "").replace("${}", `${(rtDnSlider.value / kb_act_div).toFixed(2)}`)}`;
            if (rt_mode[sel_vec[0]] == 0) {
                RTSw.checked = false;
                RTConn.checked = false;
            }
            else {
                RTSw.checked = true;
                RTConn.checked = false;
                if (rt_mode[sel_vec[0]] == 2) {
                    RTConn.checked = true;
                }
            }
            deselectedAll.disabled = false;
        }
        if (RTSw.checked) {
            rtUpSlider.disabled = false;
            rtDnSlider.disabled = false;
            RTConn.disabled = false;
        }
        else {
            rtUpSlider.disabled = true;
            rtDnSlider.disabled = true;
            RTConn.disabled = true;
        }
        if (cnt_global) {
            resetToGlobal.disabled = false;
            resetToGlobal.setAttribute("style", "color: rgb(var(--mdui-color-on-tertiary-container)); background-color: rgb(var(--mdui-color-tertiary-container));");
        }
        else {
            resetToGlobal.disabled = true;
            resetToGlobal.removeAttribute("style");
        }
        if (has_global) {
            resetAllToGlobal.disabled = false;
            resetAllToGlobal.setAttribute("style", "color: rgb(var(--mdui-color-on-tertiary-container)); background-color: rgb(var(--mdui-color-tertiary-container));");
        }
        else {
            resetAllToGlobal.disabled = true;
            resetAllToGlobal.removeAttribute("style");
        }
        if (auto_calibrate)
            autoCalSW.checked = true;
        else
            autoCalSW.checked = false;
        if (is_nkro)
            isNKROSw.checked = true;
        else
            isNKROSw.checked = false;
        Array.from(prof).forEach(async function (keys, i) {
            if (kb_profile !== i) {
                keys.variant = 'outlined';
                keys.setAttribute('style', '');
            }
            else {
                const t1 = document.getElementById('tab-1');
                keys.variant = 'tonal';
                keys.setAttribute('style', 'border-color: rgb(var(--mdui-color-primary))!important; border-style: solid; border-width: 3px;');
                if (tab_sel.value == 'tab-1') {
                    if (kb_profile == 0) {
                        linkprof.parentElement.hidden = true;
                        t1.hidden = false;
                    }
                    else {
                        linkprof.parentElement.hidden = false;
                        if (link_profile & (1 << kb_profile)) {
                            linkprof.checked = true;
                            t1.hidden = true;
                        }
                        else {
                            linkprof.checked = false;
                            t1.hidden = false;
                        }
                    }
                }
            }
            if (fw_number == 0) {
                currfwtext.innerHTML = `${(await getTranslation("current_firmware") ?? "").replace("${}", "(Unknown)")}`;
                currfwtextdrawer.innerHTML = `${(await getTranslation("current_firmware") ?? "").replace("${}", "(Unknown)")}`;
            }
            else {
                let text_build;
                if (curr_fw_build == "beta")
                    text_build = (await getTranslation("firmware_beta") ?? "");
                else
                    text_build = (await getTranslation("firmware_stable") ?? "");
                currfwtext.innerHTML = `${(await getTranslation("current_firmware") ?? "").replace("${}", `V${pad(fw_number.toString())} (${text_build})`)}`;
                currfwtextdrawer.innerHTML = `${(await getTranslation("current_firmware") ?? "").replace("${}", `V${pad(fw_number.toString())} (${text_build})`)}`;
            }
            if (new_fw_number > fw_number) {
                fwupdatebtndrawer.disabled = false;
            }
            else {
                fwupdatebtndrawer.disabled = true;
            }
            let text_build;
            if (new_fw_build == "beta")
                text_build = (await getTranslation("firmware_beta") ?? "");
            else
                text_build = (await getTranslation("firmware_stable") ?? "");
            newfwtext.innerHTML = `${(await getTranslation("new_firmware") ?? "").replace("${}", `V${pad(new_fw_number.toString())} (${text_build})`)}`;
        });
        socd_mode_1.checked = false;
        socd_mode_2.checked = false;
        socd_mode_3.checked = false;
        socd_mode_41.checked = false;
        socd_mode_42.checked = false;
        socd_both_bottom_out.checked = false;
        socd_mode_1.disabled = true;
        socd_mode_2.disabled = true;
        socd_mode_3.disabled = true;
        socd_mode_41.disabled = true;
        socd_mode_42.disabled = true;
        socd_both_bottom_out.disabled = true;
        if (tab_selection == 12) {
            if (sel_vec.length == 2) {
                socd_mode_1.disabled = false;
                socd_mode_2.disabled = false;
                socd_mode_3.disabled = false;
                socd_mode_41.disabled = false;
                socd_mode_42.disabled = false;
                socd_both_bottom_out.disabled = false;
                socd_mode_41_head.innerHTML = "\"Key1\" high priority";
                socd_mode_42_head.innerHTML = "\"Key2\" high priority";
                let curr_mode = socd_mode[sel_vec[0]] & 0x3f;
                if (curr_mode == 0) {
                    curr_mode = 0;
                    socd_both_bottom_out.checked = false;
                }
                if (curr_mode == 1) {
                    socd_mode_1.checked = true;
                }
                else if (curr_mode == 2) {
                    socd_mode_2.checked = true;
                }
                else if (curr_mode == 3) {
                    socd_mode_3.checked = true;
                }
                else if (curr_mode == 4) {
                    socd_mode_41.checked = true;
                }
                else if (curr_mode == 5) {
                    socd_mode_42.checked = true;
                }
                if ((socd_mode[sel_vec[0]] & 0xc0) == 0xc0) {
                    socd_both_bottom_out.checked = true;
                }
                socd_mode_41_head.innerHTML = `\"${socd_key_text_41.trim()}\" high priority`;
                socd_mode_42_head.innerHTML = `\"${socd_key_text_42.trim()}\" high priority`;
            }
            else {
                socd_mode_41_head.innerHTML = "\"Key1\" high priority";
                socd_mode_42_head.innerHTML = "\"Key2\" high priority";
            }
        }
    }
    async function updateUITap(element, value) {
        let line1 = '';
        let line2 = '';
        let found = 0;
        element.setAttribute('variant', 'tonal');
        for (const elem of layer_key) {
            if (elem.v == value &&
                found == 0) {
                found = 1;
                if (elem.hasOwnProperty('t'))
                    line1 = elem.t;
            }
            if (found)
                break;
        }
        for (const elem of speci_key) {
            if (elem.v == value &&
                found == 0) {
                found = 1;
                if (elem.hasOwnProperty('t'))
                    line1 = elem.t;
                if (elem.hasOwnProperty('t2'))
                    line2 = elem.t2;
            }
            if (found)
                break;
        }
        for (const elem of basic_key) {
            if (elem.v == value &&
                found == 0) {
                found = 1;
                if (elem.hasOwnProperty('t'))
                    line1 = elem.t;
                if (elem.hasOwnProperty('t2'))
                    line2 = elem.t2;
            }
            if (found)
                break;
        }
        for (const elem of advan_key) {
            if (elem.v == value &&
                found == 0) {
                found = 1;
                if (elem.hasOwnProperty('t'))
                    line1 = elem.t;
                if (elem.hasOwnProperty('t2'))
                    line2 = elem.t2;
            }
            if (found)
                break;
        }
        element.innerHTML = `
          <div style="font-size: 8px; position: absolute; top: 9px; left: 80px;">
            <mdui-icon name="edit"></mdui-icon>
          </div>
          <div style="line-height: 1.4; font-size: ${font_size};">
            <div style="width: 100%;">
                ${line1}
            </div>
            <div style="width: 100%;">
                
            </div>
            <div style="width: 100%;">
                ${line2}
            </div>
          </div>
          `;
    }
    const profile_sw = Array.from(prof);
    profile_sw.forEach(function (key) {
        key.addEventListener('click', async function (event) {
            profile_sw.forEach(async function (keys, i) {
                if (key == keys) {
                    if ((tab_sel.value == 'tab-5'))
                        tab_sel.value = 'tab-1';
                    await tab_sel_func();
                    await sleep(20);
                    loadprofile(i);
                }
            });
        });
    });
    linkprof.addEventListener('change', async function () {
        if (linkprof.checked == true) {
            link_profile |= 1 << kb_profile;
        }
        else {
            link_profile &= ~(1 << kb_profile);
        }
        await sendDataTimeout([
            86,
            link_profile,
        ]);
        await loadprofile(kb_profile);
    });
    const layer_sw = Array.from(layer);
    layer_sw.forEach(function (key) {
        key.addEventListener('click', async function (event) {
            layer_sw.forEach(function (keys, i) {
                if (key !== keys) {
                    keys.variant = 'outlined';
                    keys.setAttribute('style', '');
                }
                else {
                    keys.variant = 'tonal';
                    keys.setAttribute('style', 'border-color: rgb(var(--mdui-color-primary))!important; border-style: solid; border-width: 3px;');
                    kb_layer = i;
                    resetSelKey();
                    remap_mode = 0;
                    updateUI();
                }
            });
            updateKB();
        });
    });
    rawSw.addEventListener('change', async function (event) {
        if (rawSw.checked) {
            raw_enable = 1;
        }
        else {
            raw_enable = 0;
        }
    });
    resetKeypress.addEventListener('click', async function () {
        for (let i = 0; i < 128; ++i) {
            raw_matrix_mark[i] = 0;
        }
        updateKB();
    });
    tab_sel.addEventListener('change', async function (event) {
        if (tab_sel.value === undefined)
            tab_sel.value = tab_sel_prev;
        else
            tab_sel_prev = tab_sel.value;
        if (tab_sel.value === undefined)
            tab_sel.value = 'tab-1';
        if (fw_number < 30 && tab_sel.value == 'tab-12')
            tab_sel.value = 'tab-1';
        clearInterval(interval);
        interval_halt = 1;
        tab_sel_func();
    });
    const t1 = document.getElementById('tab-1');
    const t2 = document.getElementById('tab-2');
    const t3 = document.getElementById('tab-3');
    const t4 = document.getElementById('tab-4');
    const t5 = document.getElementById('tab-5');
    const t6 = document.getElementById('tab-6');
    const t10 = document.getElementById('tab-10');
    const t11 = document.getElementById('tab-11');
    const t12 = document.getElementById('tab-12');
    async function tab_sel_func() {
        t1.hidden = true;
        t2.hidden = true;
        t3.hidden = true;
        t4.hidden = true;
        t5.hidden = true;
        t6.hidden = true;
        t10.hidden = false;
        t11.hidden = true;
        t12.hidden = true;
        rawSw.checked = false;
        raw_enable = 0;
        raw_matrix.forEach(function (keys, i) {
            raw_matrix[i] = 0;
        });
        remap_mode = 0;
        clearInterval(interval);
        switch (tab_sel.value) {
            case 'tab-1':
                t1.hidden = false;
                t11.hidden = false;
                tab_selection = 0;
                Array.from(layer).forEach(function (keys, i) {
                    if (i == 0) {
                        keys.variant = 'tonal';
                        keys.setAttribute('style', 'border-color: rgb(var(--mdui-color-primary))!important; border-style: solid; border-width: 3px;');
                        kb_layer = i;
                    }
                    else {
                        keys.variant = 'outlined';
                        keys.setAttribute('style', '');
                    }
                });
                break;
            case 'tab-2':
                t2.hidden = false;
                t12.hidden = false;
                toggle_keybind = 0;
                showKeyBind.innerHTML = `${await getTranslation("show_keybind")}`;
                showKeyBind.setAttribute('style', 'border-color: rgb(var(--mdui-color-outline-variant))!important; border-style: solid; border-width: 0.0625rem;');
                tab_selection = 1;
                break;
            case 'tab-12':
                t6.hidden = false;
                e1.innerHTML = "Key 1";
                e2.innerHTML = "Key 2";
                tab_selection = 12;
                break;
            case 'tab-3':
                t3.hidden = false;
                tab_selection = 2;
                raw_enable = 1;
                rawSw.checked = true;
                interval_halt = 0;
                interval = null;
                if (await checkUsagePage()) {
                    interval = setInterval(function () {
                        getrawmatrix();
                    }, 50);
                }
                break;
            case 'tab-4':
                t4.hidden = false;
                t10.hidden = true;
                tab_selection = 3;
                break;
            case 'tab-5':
                t5.hidden = false;
                tab_selection = 4;
                interval_halt = 0;
                interval = null;
                if (await checkUsagePage()) {
                    interval = setInterval(function () {
                        getdebugvalue();
                    }, 125);
                }
                break;
            default:
        }
        is_sel.forEach(async function (value, i, element) {
            element[i] = 0;
        });
        sel_vec = [];
        updateKB();
        updateUI();
    }
    actuationSlider.addEventListener('input', async function (event) {
        if (actuationSlider.value < kb_act_min)
            actuationSlider.value = kb_act_min;
        else if (actuationSlider.value > actuationSlider.max - 2)
            actuationSlider.value = actuationSlider.max - 2;
    });
    actuationSlider.addEventListener('change', async function (event) {
        if (actuationSlider.value < kb_act_min)
            actuationSlider.value = kb_act_min;
        else if (actuationSlider.value > actuationSlider.max - 2)
            actuationSlider.value = actuationSlider.max - 2;
        let c = 0;
        let q = new Uint8Array(128);
        let pack = new Uint8Array(64);
        const data = actuationSlider.value;
        if (is_default_slider) {
            ap_dis.forEach(async function (value, i) {
                if (is_global[i] == 1) {
                    ap_dis[i] = data;
                }
            });
            updateKB();
            updateUI();
            await sendDataTimeout([
                160,
                0x00,
                data,
                0xff,
            ]);
        }
        else {
            is_sel.forEach(async function (value, i) {
                if (value == 1) {
                    ap_dis[i] = data;
                    is_global[i] = 0;
                }
            });
            updateKB();
            updateUI();
            is_sel.forEach(async function (value, i) {
                if (value == 1) {
                    ap_dis[i] = data;
                    is_global[i] = 0;
                    q[c] = i;
                    c++;
                    if (c == 16) {
                        pack[3] = c;
                        for (let i = 0; i < c; ++i) {
                            pack[4 + i] = q[i];
                        }
                        pack[0] = 160;
                        pack[2] = data;
                        await sendDataTimeout(pack);
                        pack[0] = 170;
                        pack[2] = 0x00;
                        await sendDataTimeout(pack);
                        pack = new Uint8Array(64);
                        q = new Uint8Array(128);
                        c = 0;
                    }
                }
            });
            if (c > 0 && c <= 16) {
                pack[3] = c;
                for (let i = 0; i < c; ++i) {
                    pack[4 + i] = q[i];
                }
                pack[0] = 160;
                pack[2] = data;
                await sendDataTimeout(pack);
                pack[0] = 170;
                pack[2] = 0x00;
                await sendDataTimeout(pack);
                pack = new Uint8Array(64);
                q = new Uint8Array(128);
                c = 0;
            }
        }
    });
    rtUpSlider.addEventListener('input', async function (event) {
        if (rtUpSlider.value < 2)
            rtUpSlider.value = 2;
        else if (rtUpSlider.value > rtUpSlider.max - 2)
            rtUpSlider.value = rtUpSlider.max - 2;
    });
    rtUpSlider.addEventListener('change', async function (event) {
        if (rtUpSlider.value < 2)
            rtUpSlider.value = 2;
        else if (rtUpSlider.value > rtUpSlider.max - 2)
            rtUpSlider.value = rtUpSlider.max - 2;
        let c = 0;
        let q = new Uint8Array(128);
        let pack = new Uint8Array(64);
        const data = rtUpSlider.value;
        if (is_default_slider) {
            rt_up.forEach(async function (value, i) {
                if (is_global[i] == 1) {
                    rt_up[i] = data;
                }
            });
            updateKB();
            updateUI();
            await sendDataTimeout([
                161,
                0x00,
                data,
                0xff,
            ]);
        }
        else {
            is_sel.forEach(async function (value, i) {
                if (value == 1) {
                    rt_up[i] = data;
                    is_global[i] = 0;
                }
            });
            updateKB();
            updateUI();
            is_sel.forEach(async function (value, i) {
                if (value == 1) {
                    q[c] = i;
                    c++;
                    if (c == 16) {
                        pack[3] = c;
                        for (let i = 0; i < c; ++i) {
                            pack[4 + i] = q[i];
                        }
                        pack[0] = 161;
                        pack[2] = data;
                        await sendDataTimeout(pack);
                        pack[0] = 170;
                        pack[2] = 0x00;
                        await sendDataTimeout(pack);
                        pack = new Uint8Array(64);
                        q = new Uint8Array(128);
                        c = 0;
                    }
                }
            });
            if (c > 0 && c <= 16) {
                pack[3] = c;
                for (let i = 0; i < c; ++i) {
                    pack[4 + i] = q[i];
                }
                pack[0] = 161;
                pack[2] = data;
                await sendDataTimeout(pack);
                pack[0] = 170;
                pack[2] = 0x00;
                await sendDataTimeout(pack);
                pack = new Uint8Array(64);
                q = new Uint8Array(128);
                c = 0;
            }
        }
    });
    rtDnSlider.addEventListener('input', async function (event) {
        if (rtDnSlider.value < 2)
            rtDnSlider.value = 2;
        else if (rtDnSlider.value > rtDnSlider.max - 2)
            rtDnSlider.value = rtDnSlider.max - 2;
    });
    rtDnSlider.addEventListener('change', async function (event) {
        if (rtDnSlider.value < 2)
            rtDnSlider.value = 2;
        else if (rtDnSlider.value > rtDnSlider.max - 2)
            rtDnSlider.value = rtDnSlider.max - 2;
        let c = 0;
        let q = new Uint8Array(128);
        let pack = new Uint8Array(64);
        const data = rtDnSlider.value;
        if (is_default_slider) {
            rt_dn.forEach(async function (value, i) {
                if (is_global[i] == 1) {
                    rt_dn[i] = data;
                }
            });
            updateKB();
            updateUI();
            await sendDataTimeout([
                162,
                0x00,
                data,
                0xff,
            ]);
        }
        else {
            is_sel.forEach(async function (value, i) {
                if (value == 1) {
                    rt_dn[i] = data;
                    is_global[i] = 0;
                }
            });
            updateKB();
            updateUI();
            is_sel.forEach(async function (value, i) {
                if (value == 1) {
                    q[c] = i;
                    c++;
                    if (c == 16) {
                        pack[3] = c;
                        for (let i = 0; i < c; ++i) {
                            pack[4 + i] = q[i];
                        }
                        pack[0] = 162;
                        pack[2] = data;
                        await sendDataTimeout(pack);
                        pack[0] = 170;
                        pack[2] = 0x00;
                        await sendDataTimeout(pack);
                        pack = new Uint8Array(64);
                        q = new Uint8Array(128);
                        c = 0;
                    }
                }
            });
            if (c > 0 && c <= 16) {
                pack[3] = c;
                for (let i = 0; i < c; ++i) {
                    pack[4 + i] = q[i];
                }
                pack[0] = 162;
                pack[2] = data;
                await sendDataTimeout(pack);
                pack[0] = 170;
                pack[2] = 0x00;
                await sendDataTimeout(pack);
                pack = new Uint8Array(64);
                q = new Uint8Array(128);
                c = 0;
            }
        }
    });
    RTSw.addEventListener('change', async function (event) {
        let data = 0x02;
        if (RTSw.checked) {
            rtUpSlider.disabled = false;
            rtDnSlider.disabled = false;
            RTConn.disabled = false;
            if (RTConn.checked) {
                data = 0x02;
            }
            else {
                data = 0x01;
            }
        }
        else {
            rtUpSlider.disabled = true;
            rtDnSlider.disabled = true;
            RTConn.disabled = true;
            data = 0x00;
        }
        let c = 0;
        let q = new Uint8Array(128);
        let pack = new Uint8Array(64);
        if (is_default_slider) {
            rt_dn.forEach(async function (value, i) {
                if (is_global[i] == 1) {
                    rt_mode[i] = data;
                }
            });
            updateKB();
            updateUI();
            await sendDataTimeout([
                163,
                0x00,
                data,
                0xff,
            ]);
        }
        else {
            is_sel.forEach(async function (value, i) {
                if (value == 1) {
                    rt_mode[i] = data;
                    is_global[i] = 0;
                }
            });
            updateKB();
            updateUI();
            is_sel.forEach(async function (value, i) {
                if (value == 1) {
                    q[c] = i;
                    c++;
                    if (c == 16) {
                        pack[3] = c;
                        for (let i = 0; i < c; ++i) {
                            pack[4 + i] = q[i];
                        }
                        pack[0] = 163;
                        pack[2] = data;
                        await sendDataTimeout(pack);
                        pack[0] = 170;
                        pack[2] = 0x00;
                        await sendDataTimeout(pack);
                        pack = new Uint8Array(64);
                        q = new Uint8Array(128);
                        c = 0;
                    }
                }
            });
            if (c > 0 && c <= 16) {
                pack[3] = c;
                for (let i = 0; i < c; ++i) {
                    pack[4 + i] = q[i];
                }
                pack[0] = 163;
                pack[2] = data;
                await sendDataTimeout(pack);
                pack[0] = 170;
                pack[2] = 0x00;
                await sendDataTimeout(pack);
                pack = new Uint8Array(64);
                q = new Uint8Array(128);
                c = 0;
            }
        }
    });
    RTConn.addEventListener('change', async function (event) {
        let data = 0x02;
        if (RTSw.checked) {
            rtUpSlider.disabled = false;
            rtDnSlider.disabled = false;
            RTConn.disabled = false;
            if (RTConn.checked) {
                data = 0x02;
            }
            else {
                data = 0x01;
            }
        }
        else {
            rtUpSlider.disabled = true;
            rtDnSlider.disabled = true;
            RTConn.disabled = true;
            data = 0x00;
        }
        let c = 0;
        let q = new Uint8Array(128);
        let pack = new Uint8Array(64);
        if (is_default_slider) {
            rt_dn.forEach(async function (value, i) {
                if (is_global[i] == 1) {
                    rt_mode[i] = data;
                }
            });
            updateKB();
            updateUI();
            await sendDataTimeout([
                163,
                0x00,
                data,
                0xff,
            ]);
        }
        else {
            is_sel.forEach(async function (value, i) {
                if (value == 1) {
                    rt_mode[i] = data;
                    is_global[i] = 0;
                }
            });
            updateKB();
            updateUI();
            is_sel.forEach(async function (value, i) {
                if (value == 1) {
                    q[c] = i;
                    c++;
                    if (c == 16) {
                        pack[3] = c;
                        for (let i = 0; i < c; ++i) {
                            pack[4 + i] = q[i];
                        }
                        pack[0] = 163;
                        pack[2] = data;
                        await sendDataTimeout(pack);
                        pack[0] = 170;
                        pack[2] = 0x00;
                        await sendDataTimeout(pack);
                        pack = new Uint8Array(64);
                        q = new Uint8Array(128);
                        c = 0;
                    }
                }
            });
            if (c > 0 && c <= 16) {
                pack[3] = c;
                for (let i = 0; i < c; ++i) {
                    pack[4 + i] = q[i];
                }
                pack[0] = 163;
                pack[2] = data;
                await sendDataTimeout(pack);
                pack[0] = 170;
                pack[2] = 0x00;
                await sendDataTimeout(pack);
                pack = new Uint8Array(64);
                q = new Uint8Array(128);
                c = 0;
            }
        }
    });
    deadzoneSlider.addEventListener('change', async function () {
        const data = deadzoneSlider.value;
        deadzone.forEach(async function (value, i) {
            deadzone[i] = data;
        });
        updateUI();
        await sendDataTimeout([
            164,
            0x00,
            data,
            0xff,
        ]);
    });
    swSelect.addEventListener('change', async function (event) {
        clearInterval(interval);
        if (typeof swSelect.value === "string") {
            if (is_jade[127] != parseInt(swSelect.value)) {
                popupinner.innerHTML = `Changing Switch`;
                popupdialog.open = true;
                let swtype = parseInt(swSelect.value);
                let swdist = sw_dist(swtype);
                actuationSlider.value = 80 + 2;
                rtUpSlider.value = 80 + 2;
                rtDnSlider.value = 80 + 2;
                for (let i = 0; i < 128; ++i) {
                    is_jade[i] = swtype;
                    if (ap_dis[i] > swdist) {
                        ap_dis[i] = swdist;
                    }
                    if (rt_up[i] > swdist) {
                        rt_up[i] = swdist;
                    }
                    if (rt_dn[i] > swdist) {
                        rt_dn[i] = swdist;
                    }
                    if (ap_dis_dual[i] > swdist) {
                        ap_dis_dual[i] = swdist;
                    }
                }
                if (await checkUsagePage()) {
                    await sendDataTimeout([175, 0x00, parseInt(swSelect.value), 0xff]);
                    while (myQueue.isBusy()) {
                        await sleep(1);
                    }
                }
                console.log(`is_jade ${parseInt(swSelect.value)}`);
                updateUI();
                popupdialog.open = false;
            }
        }
    });
    function sw_dist(sw_type) {
        if (sw_type == 0) {
            return 80;
        }
        else if (sw_type == 1) {
            return 68;
        }
        else if (sw_type == 2) {
            return 78;
        }
        else if (sw_type == 3) {
            return 66;
        }
        else {
            return 80;
        }
    }
    showKeyBind.addEventListener('click', async function (event) {
        if (toggle_keybind == 0) {
            toggle_keybind = 1;
            showKeyBind.innerHTML = `${await getTranslation("hide_keybind")}`;
            showKeyBind.setAttribute('style', 'border-color: rgb(var(--mdui-color-primary))!important; border-style: solid; border-width: 3px;');
        }
        else {
            toggle_keybind = 0;
            showKeyBind.innerHTML = `${await getTranslation("show_keybind")}`;
            showKeyBind.setAttribute('style', 'border-color: rgb(var(--mdui-color-outline-variant))!important; border-style: solid; border-width: 0.0625rem;');
        }
        updateKB();
    });
    deselectedAll.addEventListener('click', async function (event) {
        resetSelKey();
        deselectedAll.disabled = true;
        resetToGlobal.disabled = true;
        updateUI();
    });
    resetToGlobal.addEventListener('click', async function (event) {
        let c = 0;
        let q = new Uint8Array(128);
        let pack = new Uint8Array(64);
        is_sel.forEach(async function (value, i) {
            if (is_sel[i] == 1) {
                ap_dis[i] = ap_dis[127];
                rt_up[i] = rt_up[127];
                rt_dn[i] = rt_dn[127];
                rt_mode[i] = rt_mode[127];
                is_global[i] = 1;
                is_sel[i] = 0;
                q[c] = i;
                c++;
                if (c == 16) {
                    pack[3] = c;
                    for (let i = 0; i < c; ++i) {
                        pack[4 + i] = q[i];
                    }
                    pack[0] = 160;
                    pack[2] = ap_dis[127];
                    await sendDataTimeout(pack);
                    pack[0] = 161;
                    pack[2] = rt_up[127];
                    await sendDataTimeout(pack);
                    pack[0] = 162;
                    pack[2] = rt_dn[127];
                    await sendDataTimeout(pack);
                    pack[0] = 163;
                    pack[2] = rt_mode[127];
                    await sendDataTimeout(pack);
                    pack[0] = 170;
                    pack[2] = 1;
                    await sendDataTimeout(pack);
                    pack = new Uint8Array(64);
                    q = new Uint8Array(128);
                    c = 0;
                }
            }
        });
        if (c > 0 && c <= 16) {
            pack[3] = c;
            for (let i = 0; i < c; ++i) {
                pack[4 + i] = q[i];
            }
            pack[0] = 160;
            pack[2] = ap_dis[127];
            await sendDataTimeout(pack);
            pack[0] = 161;
            pack[2] = rt_up[127];
            await sendDataTimeout(pack);
            pack[0] = 162;
            pack[2] = rt_dn[127];
            await sendDataTimeout(pack);
            pack[0] = 163;
            pack[2] = rt_mode[127];
            await sendDataTimeout(pack);
            pack[0] = 170;
            pack[2] = 1;
            await sendDataTimeout(pack);
            pack = new Uint8Array(64);
            q = new Uint8Array(128);
            c = 0;
        }
        resetSelKey();
        updateUI();
        updateKB();
    });
    const popupdialogresetToGlobal = document.getElementById("popupdialogresetToGlobal");
    const popupdialogresetToGlobalY = document.getElementById("popupdialogresetToGlobalY");
    const popupdialogresetToGlobalN = document.getElementById("popupdialogresetToGlobalN");
    resetAllToGlobal.addEventListener('click', async function (event) {
        popupdialogresetToGlobal.open = true;
    });
    popupdialogresetToGlobalN.addEventListener('click', async function (event) {
        popupdialogresetToGlobal.open = false;
    });
    popupdialogresetToGlobalY.addEventListener('click', async function (event) {
        popupdialogresetToGlobal.open = false;
        let c = 0;
        let q = new Uint8Array(128);
        let pack = new Uint8Array(64);
        is_sel.forEach(async function (value, i) {
            if (is_global[i] == 0) {
                ap_dis[i] = ap_dis[127];
                rt_up[i] = rt_up[127];
                rt_dn[i] = rt_dn[127];
                rt_mode[i] = rt_mode[127];
            }
        });
        is_sel.forEach(async function (value, i) {
            if (is_global[i] == 0) {
                is_global[i] = 1;
                is_sel[i] = 0;
                q[c] = i;
                c++;
                if (c == 16) {
                    pack[3] = c;
                    for (let i = 0; i < c; ++i) {
                        pack[4 + i] = q[i];
                    }
                    pack[0] = 160;
                    pack[2] = ap_dis[127];
                    await sendDataTimeout(pack);
                    pack[0] = 161;
                    pack[2] = rt_up[127];
                    await sendDataTimeout(pack);
                    pack[0] = 162;
                    pack[2] = rt_dn[127];
                    await sendDataTimeout(pack);
                    pack[0] = 163;
                    pack[2] = rt_mode[127];
                    await sendDataTimeout(pack);
                    pack[0] = 170;
                    pack[2] = 1;
                    await sendDataTimeout(pack);
                    pack = new Uint8Array(64);
                    q = new Uint8Array(128);
                    c = 0;
                }
            }
        });
        if (c > 0 && c <= 16) {
            pack[3] = c;
            for (let i = 0; i < c; ++i) {
                pack[4 + i] = q[i];
            }
            pack[0] = 160;
            pack[2] = ap_dis[127];
            await sendDataTimeout(pack);
            pack[0] = 161;
            pack[2] = rt_up[127];
            await sendDataTimeout(pack);
            pack[0] = 162;
            pack[2] = rt_dn[127];
            await sendDataTimeout(pack);
            pack[0] = 163;
            pack[2] = rt_mode[127];
            await sendDataTimeout(pack);
            pack[0] = 170;
            pack[2] = 1;
            await sendDataTimeout(pack);
            pack = new Uint8Array(64);
            q = new Uint8Array(128);
            c = 0;
        }
        updateUI();
        updateKB();
    });
    recalibratebtn.addEventListener("click", async function () {
        interval_halt = 1;
        await sleep(500);
        await sendDataTimeout([214]);
        await sleep(1000);
        interval_halt = 0;
    });
    autoCalSW.addEventListener("change", async function () {
        interval_halt = 1;
        await sleep(500);
        if (autoCalSW.checked)
            auto_calibrate = 1;
        else
            auto_calibrate = 0;
        await sendDataTimeout([213, 0x01, auto_calibrate]);
        await sleep(1000);
        interval_halt = 0;
    });
    async function socd_func(mode, check) {
        socd_mode_1.checked = false;
        socd_mode_2.checked = false;
        socd_mode_3.checked = false;
        socd_mode_41.checked = false;
        socd_mode_42.checked = false;
        let mark_bit = 0;
        let key1 = sel_vec[0], key2 = sel_vec[1];
        let curr_mode = 0;
        if (check)
            curr_mode = mode;
        if (curr_mode == 0)
            socd_both_bottom_out.checked = false;
        if (socd_both_bottom_out.checked)
            mark_bit = 0x00c0;
        if (curr_mode == 0) {
            socd_key[key1] = 0;
            socd_key[key2] = 0;
            socd_mode[key1] = 0;
            socd_mode[key2] = 0;
            sendDataTimeout([172, 0, 0, 1, key1]);
            sendDataTimeout([172, 0, 0, 1, key2]);
            sendDataTimeout([173, 0, 0, 2, key1, key2]);
        }
        else {
            socd_key[key1] = key2;
            socd_key[key2] = key1;
            sendDataTimeout([172, 0, key2, 1, key1]);
            sendDataTimeout([172, 0, key1, 1, key2]);
        }
        console.log(curr_mode | mark_bit);
        switch (curr_mode) {
            case 1:
                socd_mode_1.checked = true;
                socd_mode[key1] = 1 | mark_bit;
                socd_mode[key2] = 1 | mark_bit;
                sendDataTimeout([173, 0, 1 | mark_bit, 2, key1, key2]);
                break;
            case 2:
                socd_mode_2.checked = true;
                socd_mode[key1] = 2 | mark_bit;
                socd_mode[key2] = 2 | mark_bit;
                sendDataTimeout([173, 0, 2 | mark_bit, 2, key1, key2]);
                break;
            case 3:
                socd_mode_3.checked = true;
                socd_mode[key1] = 3 | mark_bit;
                socd_mode[key2] = 3 | mark_bit;
                sendDataTimeout([173, 0, 3 | mark_bit, 2, key1, key2]);
                break;
            case 41:
                socd_mode_41.checked = true;
                socd_mode[key1] = 4 | mark_bit;
                socd_mode[key2] = 5 | mark_bit;
                sendDataTimeout([173, 0, 4 | mark_bit, 1, key1]);
                sendDataTimeout([173, 0, 5 | mark_bit, 1, key2]);
                break;
            case 42:
                socd_mode_42.checked = true;
                socd_mode[key1] = 5 | mark_bit;
                socd_mode[key2] = 4 | mark_bit;
                sendDataTimeout([173, 0, 5 | mark_bit, 1, key1]);
                sendDataTimeout([173, 0, 4 | mark_bit, 1, key2]);
                break;
        }
        updateKB();
    }
    socd_mode_1.addEventListener("change", async function () {
        await socd_func(1, socd_mode_1.checked);
    });
    socd_mode_2.addEventListener("change", async function () {
        await socd_func(2, socd_mode_2.checked);
    });
    socd_mode_3.addEventListener("change", async function () {
        await socd_func(3, socd_mode_3.checked);
    });
    socd_mode_41.addEventListener("change", async function () {
        await socd_func(41, socd_mode_41.checked);
    });
    socd_mode_42.addEventListener("change", async function () {
        await socd_func(42, socd_mode_42.checked);
    });
    socd_both_bottom_out.addEventListener("change", async function () {
        if (socd_mode_1.checked)
            socd_func(1, socd_mode_1.checked);
        else if (socd_mode_2.checked)
            socd_func(2, socd_mode_2.checked);
        else if (socd_mode_3.checked)
            socd_func(3, socd_mode_3.checked);
        else if (socd_mode_41.checked)
            socd_func(41, socd_mode_41.checked);
        else if (socd_mode_42.checked)
            socd_func(42, socd_mode_42.checked);
        else
            socd_both_bottom_out.checked = false;
    });
    isNKROSw.addEventListener("change", async function () {
        if (isNKROSw.checked)
            is_nkro = 1;
        else
            is_nkro = 0;
        await sendDataTimeout([216, 0x01, is_nkro]);
    });
    const popupdialogfactoryreset = document.getElementById("popupdialogfactoryreset");
    const popupdialogfactoryresetY = document.getElementById("popupdialogfactoryresetY");
    const popupdialogfactoryresetN = document.getElementById("popupdialogfactoryresetN");
    factoryreset.addEventListener('click', async function (event) {
        popupdialogfactoryreset.open = true;
    });
    popupdialogfactoryresetN.addEventListener('click', async function (event) {
        popupdialogfactoryreset.open = false;
    });
    popupdialogfactoryresetY.addEventListener('click', async function (event) {
        popupdialogfactoryreset.open = false;
        await sendDataTimeout([238, 0xff, 0xff]);
        await loadKeyboardSetting();
        updateUI();
        updateKB();
    });
    const popupdialoglayoutsetting = document.getElementById("popupdialoglayoutsetting");
    const popupdialoglayoutsettingY = document.getElementById("popupdialoglayoutsettingY");
    const popupdialoglayoutsettingN = document.getElementById("popupdialoglayoutsettingN");
    const sw7u_menu = document.getElementById("sw7u_menu");
    const swspltbspc_menu = document.getElementById("swspltbspc_menu");
    const sw7u = document.getElementById("sw7u");
    const swspltbspc = document.getElementById("swspltbspc");
    swlayout.addEventListener('click', async function (event) {
        if ((kb_layout_support & 0x0001) == 0)
            sw7u_menu.hidden = true;
        else {
            sw7u_menu.hidden = false;
            if ((kb_layout & 0x0001) == 0x0001) {
                sw7u.checked = true;
            }
            else {
                sw7u.checked = false;
            }
        }
        if ((kb_layout_support & 0x0002) == 0)
            swspltbspc_menu.hidden = true;
        else {
            swspltbspc_menu.hidden = false;
            if ((kb_layout & 0x0002) == 0x0002) {
                swspltbspc.checked = true;
            }
            else {
                swspltbspc.checked = false;
            }
        }
        popupdialoglayoutsetting.open = true;
        popupdialoglayoutsetting.open = true;
    });
    popupdialoglayoutsettingN.addEventListener('click', async function (event) {
        popupdialoglayoutsetting.open = false;
    });
    popupdialoglayoutsettingY.addEventListener('click', async function (event) {
        kb_layout = 0;
        if (sw7u.checked == true)
            kb_layout |= 0x0001;
        if (swspltbspc.checked == true)
            kb_layout |= 0x0002;
        await sendDataTimeout([217, 0x01, kb_layout]);
        await sleep(50);
        await loadKeyboardSetting();
        await createKeyboardjson(hidDevice.productId);
        updateUI();
        updateKB();
        popupdialoglayoutsetting.open = false;
    });
    document.addEventListener('focusout', () => {
        keytest.innerHTML = '';
        keytest2.innerHTML = '';
    });
    document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'hidden') {
            keytest.innerHTML = '';
            keytest2.innerHTML = '';
        }
    });
    const kb = window.navigator;
    if (kb?.keyboard) {
        kb.keyboard.getLayoutMap().then(function (keyboardLayoutMap) {
            let keytestlist = document.querySelectorAll('.keytest');
            let keytestlist2 = document.querySelectorAll('.keytest2');
            document.onkeydown = (event) => {
                event.preventDefault();
                let chk = 1;
                keytestlist = document.querySelectorAll('.keytest');
                Array.from(keytestlist).forEach(function (element, i) {
                    if (element.dataset.value == event.code)
                        chk = 0;
                });
                if (chk) {
                    const key = document.createElement('div');
                    const size = `key-auto`;
                    let code = event.code;
                    if (keyboardLayoutMap.get(event.code))
                        code = keyboardLayoutMap.get(event.code);
                    if (code.length == 0)
                        code = event.key;
                    key.innerHTML = `
                        <mdui-button data-value="${event.code}" variant="outlined" class="${size} keytest" style="display: inline-block;" disabled>
                            <div style="line-height: 1.4; font-size: 14px;">
                                <div style="width: 100%;">
                                    ${code}
                                </div>
                            </div>
                        </mdui-button>
                        `;
                    key.innerHTML = `
                        <mdui-card data-value="${event.code}" variant="outlined" class="${size} keytest" style="display: inline-block;">
                            <div style="line-height: 1.4; font-size: 14px; display: flex; align-items: center; justify-content: center; height: 100%; padding: 0px 8px 0px 8px">
                                <div>
                                    ${code}
                                </div>
                            </div>
                        </mdui-card>
                        `;
                    key.className = 'btn-space';
                    keytest.append(key);
                }
                chk = 1;
                keytestlist2 = document.querySelectorAll('.keytest2');
                Array.from(keytestlist2).forEach(function (element, i) {
                    if (element.dataset.value == event.code)
                        chk = 0;
                });
                if (chk) {
                    const key = document.createElement('div');
                    const size = `key-auto`;
                    let code = event.code;
                    if (keyboardLayoutMap.get(event.code))
                        code = keyboardLayoutMap.get(event.code);
                    if (code.length == 0)
                        code = event.key;
                    key.innerHTML = `
                        <mdui-button data-value="${event.code}" variant="outlined" class="${size} keytest2" style="display: inline-block;" disabled>
                            <div style="line-height: 1.4; font-size: 14px;">
                                <div style="width: 100%;">
                                    ${code}
                                </div>
                            </div>
                        </mdui-button>
                        `;
                    key.innerHTML = `
                        <mdui-card data-value="${event.code}" variant="outlined" class="${size} keytest2" style="display: inline-block;">
                            <div style="line-height: 1.4; font-size: 14px; display: flex; align-items: center; justify-content: center; height: 100%; padding: 0px 8px 0px 8px">
                                <div>
                                    ${code}
                                </div>
                            </div>
                        </mdui-card>
                        `;
                    key.className = 'btn-space';
                    keytest2.append(key);
                }
            };
            document.onkeyup = (event) => {
                event.preventDefault();
                keytestlist = document.querySelectorAll('.keytest');
                Array.from(keytestlist).forEach(function (element, i) {
                    if (element.dataset.value == event.code)
                        element.parentElement.remove();
                });
                keytestlist2 = document.querySelectorAll('.keytest2');
                Array.from(keytestlist2).forEach(function (element, i) {
                    if (element.dataset.value == event.code)
                        element.parentElement.remove();
                });
            };
        });
    }
    async function loadprofile(profile) {
        kb_profile = profile;
        popupinner.innerHTML = `Loading Profile ${profile}`;
        popupdialog.open = true;
        if (await checkUsagePage()) {
            await sendDataTimeout([
                80,
                kb_profile,
            ]);
            while (myQueue.isBusy()) {
                await sleep(1);
            }
            resetSelKey();
            const a = await loadKeyboardSetting();
            while (myQueue.isBusy()) {
                await sleep(1);
            }
        }
        updateKB();
        updateUI();
        popupdialog.open = false;
    }
    async function get_serial_number() {
        let chk = 0;
        await sendDataTimeout([
            224,
            0,
        ]);
        await sendDataTimeout([
            224,
            1,
        ]);
    }
    async function get_firmware_version() {
        sendDataTimeout([
            226,
            1,
        ]);
        sendDataTimeout([
            227
        ]);
    }
    async function get_auto_calibration() {
        sendDataTimeout([213, 0x00]);
    }
    async function get_nkro_status() {
        sendDataTimeout([216, 0x00]);
    }
    async function checknewfw(productId) {
        let prodId = productId.toString();
        new_fw_number = 0;
        const response = await window.fetch(window.location.href + 'skb/firmware/' + prodId + '/firmware.json', {
            method: 'GET',
        });
        if (response.ok) {
            const r = await response.blob();
            const fw_list = JSON.parse(await r.text());
            fw_json = fw_list;
            await fw_list.firmware.forEach(async function (list) {
                if (new_fw_number < list.firmware_version) {
                    if ("beta" === fw_tar_build) {
                        new_fw_number = list.firmware_version;
                        new_fw_build = list.build;
                    }
                    else if (list.build === fw_tar_build) {
                        new_fw_number = list.firmware_version;
                        new_fw_build = list.build;
                    }
                }
                if (list.firmware_version == fw_number) {
                    curr_fw_build = list.build;
                }
            });
            return 0;
        }
        else {
            return 1;
        }
    }
    startupdate?.addEventListener("click", async function () {
        if (hidDevice.collections[0].usagePage === 0xff53 &&
            hidDevice.collections[0].usage === 0x62 &&
            hidDevice.vendorId == 21323) {
            connectFWUpdate.disabled = true;
            startupdate.disabled = true;
            exitiap.disabled = true;
            closefirmwaredialog.disabled = true;
            fwstatus.innerHTML = "Status : Downloading Firmware";
            let buffer;
            await checknewfw(hidDevice.productId);
            await fetchfirmware_new(hidDevice.productId, new_fw_number).then(function (file) {
                if (file) {
                    file.onload = async function () {
                        buffer = file;
                        console.log(MD5(new TextDecoder().decode(buffer.result)));
                        if (fw != null) {
                            fw.file = file;
                            connectFWUpdate.disabled = true;
                            startupdate.disabled = true;
                            exitiap.disabled = true;
                            closefirmwaredialog.disabled = true;
                            try {
                                await fw.updateFirmware();
                            }
                            catch (e) {
                                console.log(e);
                            }
                            firmwaredialog.open = false;
                            closefirmwaredialog.disabled = false;
                        }
                    };
                }
                else {
                    return Promise.reject(`Fail to fetch`);
                }
            });
        }
    });
    version_sel.addEventListener("change", async function () {
        let chk = 0;
        if (version_sel.value == "stable" || version_sel.value == "beta") {
            fw_tar_build = version_sel.value;
            console.log(fw_tar_build);
            chk = 1;
        }
        else {
            version_sel.value = fw_tar_build;
        }
        if (chk) {
            new_fw_number = 0;
            await checknewfw(hidDevice.productId);
            if (fw_number == 0)
                currfwtext.innerHTML = `${(await getTranslation("current_firmware") ?? "").replace("${}", "(Unknown)")}`;
            else {
                let text_build;
                if (curr_fw_build == "beta")
                    text_build = (await getTranslation("firmware_beta") ?? "");
                else
                    text_build = (await getTranslation("firmware_stable") ?? "");
                currfwtext.innerHTML = `${(await getTranslation("current_firmware") ?? "").replace("${}", `V${pad(fw_number.toString())} (${text_build})`)}`;
            }
            let text_build;
            if (new_fw_build == "beta")
                text_build = (await getTranslation("firmware_beta") ?? "");
            else
                text_build = (await getTranslation("firmware_stable") ?? "");
            newfwtext.innerHTML = `${(await getTranslation("new_firmware") ?? "").replace("${}", `V${pad(new_fw_number.toString())} (${text_build})`)}`;
        }
    });
    enteriap?.addEventListener("click", async function () {
        await sendDataTimeout([0xef, 0x53, 0x4b]);
        connectFWUpdate.disabled = false;
    });
    exitiap?.addEventListener("click", async () => {
        fw.exitIAP();
        firmwaredialog.open = false;
    });
    const fwstatus = document.getElementById("fwstatus");
    const fwprogress = document.getElementById("fwprogress");
    class Firmware {
        constructor(d) {
            this.device = d;
            this.fwstatus = new Uint8Array([0, 0, 0, 0, 0, 0]);
        }
        async openFile() {
            if (this.device === null) {
                console.log('Device is not connected');
                return null;
            }
            const e = {
                types: [
                    {
                        description: 'Binary file',
                        accept: {
                            'application/x-binary': ['.bin'],
                        },
                    },
                ],
                excludeAcceptAllOption: !0,
                multiple: !1,
            };
            let of, ob;
            try {
                [of] = await window.showOpenFilePicker(e);
            }
            catch (e) {
                console.log('not open file');
                return null;
            }
            try {
                ob = await of.getFile();
            }
            catch (e) {
                console.log("can't get file");
                return null;
            }
            const os = ob.size;
            console.log(ob);
            if (os === 0) {
                console.log('Invalid file size');
                return null;
            }
            return ob;
        }
        async updateFirmwarewithopenfile() {
            this.file = await this.openFile();
            this.updateFirmware();
        }
        async updateFirmware() {
            if (this.file == null) {
                console.log("can't get file");
                return null;
            }
            let r, l = this.file.size;
            try {
                r = await this.file.result;
                l = r.byteLength;
            }
            catch (error) {
                try {
                    r = await this.file.arrayBuffer();
                    l = this.file.size;
                }
                catch (error) {
                    console.log("can't arrayBuffer file :", error);
                    return null;
                }
            }
            this.fwstatus = new Uint8Array([0, 0, 0, 0, 0, 0]);
            console.log("Unlock Flash");
            fwstatus.innerHTML = "Status : Unlock Flash";
            await this.unlockflash();
            while (this.fwstatus[0] == 0) {
                await sleep(20);
            }
            console.log("Flashing");
            fwstatus.innerHTML = "Status : Updating";
            const s = 60;
            let x = 0, y = s;
            let b;
            let progress = 0;
            for (x = 0; x < l; x += s) {
                if (y > l)
                    y = l;
                try {
                    b = new Uint8Array(r.slice(x, y));
                    this.fwstatus = new Uint8Array([0, 0, 0, 0, 0, 0]);
                    await this.sendFirmware(b);
                    let c = 1;
                    while (this.fwstatus[0] == 0) {
                        await sleep(1);
                        c++;
                        if (c > 250) {
                            console.error('firmware upload timeout');
                            return null;
                        }
                    }
                }
                catch (error) {
                    console.log("can't slice", error);
                    return null;
                }
                y += s;
                progress = (x * 90) / l;
                if (progress > 90)
                    progress = 90;
                fwprogress.value = progress;
            }
            console.log("Verifying");
            fwstatus.innerHTML = "Status : Verifying";
            x = 0;
            y = s;
            for (x = 0; x < l; x += s) {
                if (y > l)
                    y = l;
                try {
                    b = new Uint8Array(r.slice(x, y));
                    this.fwstatus = new Uint8Array([0, 0, 0, 0, 0, 0]);
                    await this.verifyFirmware(b);
                    let c = 1;
                    while (this.fwstatus[0] == 0) {
                        await sleep(1);
                        c++;
                        if (c > 150) {
                            console.error('firmware verify timeout');
                            return null;
                        }
                    }
                }
                catch (error) {
                    console.log("can't slice", error);
                    return null;
                }
                y += s;
                progress = ((x * 10) / l) + 91;
                if (progress > 100)
                    progress = 100;
                fwprogress.value = progress;
            }
            console.log("Exit Bootloader");
            if (progress >= 100) {
                fwstatus.innerHTML = "Status : Complete";
                console.log('complete');
            }
            await sleep(500);
            await this.exitIAP();
            fwstatus.innerHTML = "Status : ";
            fwprogress.value = 0;
        }
        async unlockflash() {
            await this.device.sendReport(0, new Uint8Array([0x81, 0x00, 0x00, 0x00]));
        }
        async sendFirmware(b) {
            const headpk = new Uint8Array([0x80, b.length, 0, 0]);
            const packet = new Uint8Array([...headpk, ...b]);
            await this.device.sendReport(0, new Uint8Array(packet));
        }
        async verifyFirmware(b) {
            const headpk = new Uint8Array([0x82, b.length, 0, 0]);
            const packet = new Uint8Array([...headpk, ...b]);
            await this.device.sendReport(0, new Uint8Array(packet));
        }
        async exitIAP() {
            await this.device.sendReport(0, new Uint8Array([0x83, 0x00, 0x00, 0x00]));
        }
    }
});
async function sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
const default_KB_KEYTYPE = [
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x00,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x00,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x00,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x00,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x00,
    0x01,
    0x01,
    0x00,
    0x01,
    0x01,
    0x01,
    0x01,
    0x00,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x00,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x00,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x00,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x00,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x00,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x00,
    0x01,
    0x01,
    0x00,
    0x01,
    0x01,
    0x01,
    0x01,
    0x00,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x00,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x00,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x00,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x00,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x00,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x00,
    0x01,
    0x01,
    0x00,
    0x01,
    0x01,
    0x01,
    0x01,
    0x00,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x00,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x00,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x00,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x00,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x00,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x00,
    0x01,
    0x01,
    0x00,
    0x01,
    0x01,
    0x01,
    0x01,
    0x00,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x00,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
];
const default_KB_KEYCODE = [
    0x2b,
    0x35,
    0x29,
    0x39,
    0x3a,
    0x00,
    0xe0,
    0xe1,
    4,
    20,
    30,
    0x00,
    31,
    0xe3,
    0x3b,
    29,
    26,
    0x3c,
    32,
    0x00,
    8,
    0xe2,
    22,
    27,
    7,
    21,
    33,
    6,
    0x3d,
    25,
    34,
    9,
    5,
    10,
    23,
    0x00,
    0x3e,
    0x2c,
    35,
    28,
    36,
    0x3f,
    0x40,
    11,
    37,
    17,
    24,
    13,
    14,
    12,
    0x41,
    16,
    38,
    0x36,
    18,
    15,
    39,
    0x42,
    0x43,
    19,
    0x2d,
    0x00,
    0x33,
    0x37,
    0x00,
    0x38,
    0x2f,
    0xe6,
    0x44,
    0x00,
    0x34,
    0x5221,
    0x28,
    0x30,
    0x2e,
    0xe4,
    0x2a,
    0x00,
    0x31,
    0xe5,
    0x49,
    0x45,
    0x00,
    0x4c,
    0x46,
    0x4d,
    0x47,
    0x4a,
    0x51,
    0x52,
    0x50,
    0x4f,
    0x48,
    0x4e,
    0x4b,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x01,
    0x02,
    0x03,
    0x04,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x01,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
];
const default_KB_SETTING = [
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
];
export {};
